<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>main API documentation</title>
<meta name="description" content="@author: Alexandre Sac--Morane
alexandre.sac-morane@uclouvain.be â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main</code></h1>
</header>
<section id="section-intro">
<p>@author: Alexandre Sac&ndash;Morane
alexandre.sac-morane@uclouvain.be</p>
<p>This is the main file.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
@author: Alexandre Sac--Morane
alexandre.sac-morane@uclouvain.be

This is the main file.
&#34;&#34;&#34;

#-------------------------------------------------------------------------------
#Librairy
#-------------------------------------------------------------------------------

import numpy as np
import os
import shutil
from datetime import datetime
from pathlib import Path

#Own function and class
from Write_txt import Write_txt
from Create_i_AC import Create_i_AC_local
from Create_LG_IC import LG_tempo, From_LG_tempo_to_usable
import Owntools
import Grain
import Contact
import Contact_gw
import Report
import User

#-------------------------------------------------------------------------------

def main_iteration(dict_algorithm, dict_geometry, dict_material, dict_sollicitations, dict_sample, dict_tracker, simulation_report):
    &#39;&#39;&#39;
    Description of one PDEM iteration.

    The iteration is composed by a DEM step (to obtain a steady state configuration) and a PF step (to obtain dissolution and precipitation).

        Input :
            an algorithm dictionnary (a dict)
            a geometry dictionnary (a dict)
            a material dictionnary (a dict)
            a sollicitation dictionnary (a dict)
            a sample dictionnary (a dict)
            a tracker dictionnary (a dict)
            a simulation report (a Report)
        Output :
            Nothing but the dictionnaies and the report are updated
    &#39;&#39;&#39;
    # update element in dict
    dict_algorithm[&#39;i_PF&#39;] = dict_algorithm[&#39;i_PF&#39;] + 1

    simulation_report.write_and_print(&#39;\nIteration &#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39; / &#39;+str(dict_algorithm[&#39;n_t_PFDEM&#39;])+&#39;\n&#39;,&#39;\nITERATION PF &#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39; / &#39;+str(dict_algorithm[&#39;n_t_PFDEM&#39;])+&#39;\n&#39;)

    #prepare iteration
    if Path(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])).exists():
        shutil.rmtree(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;]))
    os.mkdir(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;]))
    os.mkdir(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/txt&#39;)
    os.mkdir(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/png&#39;)

    if dict_algorithm[&#39;MovePF_selector&#39;] == &#39;Interpolation&#39;:
        # Saving to compute a rigid body motion
        L_center_g = []
        for grain in dict_sample[&#39;L_g&#39;]:
            L_center_g.append(grain.center.copy())

    # Compute kinetic energy criteria
    Ecin_stop = 0
    for grain in dict_sample[&#39;L_g&#39;]:
        Ecin_stop = Ecin_stop + 0.5*grain.m*(dict_algorithm[&#39;Ecin_ratio&#39;]*grain.r_mean/dict_algorithm[&#39;dt_DEM&#39;])**2/len(dict_sample[&#39;L_g&#39;])

    #Update element in dict
    dict_algorithm[&#39;Ecin_stop&#39;] = Ecin_stop

    #Trackers and add element in dict
    dict_tracker[&#39;Ecin&#39;] = []
    dict_tracker[&#39;Force_applied&#39;] = []
    dict_tracker[&#39;k0_xmin&#39;] = []
    dict_tracker[&#39;k0_xmax&#39;] = []
    dict_tracker[&#39;y_box_max&#39;] = [dict_sample[&#39;y_box_max&#39;]]
    dict_tracker[&#39;Force_on_upper_wall&#39;] = []

    dict_algorithm[&#39;i_DEM&#39;] = - 1
    DEM_loop_statut = True
    simulation_report.write(&#39;\n&#39;)
    simulation_report.tic_tempo(datetime.now())

    #-----------------------------------------------------------------------------
    # DEM iteration
    #-----------------------------------------------------------------------------

    while DEM_loop_statut :
        # update element in dict
        dict_algorithm[&#39;i_DEM&#39;] = dict_algorithm[&#39;i_DEM&#39;] + 1

        for grain in dict_sample[&#39;L_g&#39;]:
            grain.init_f_control(dict_sollicitations)

        # Detection of contacts between grains
        if dict_algorithm[&#39;i_DEM&#39;] % dict_algorithm[&#39;i_update_neighborhoods&#39;]  == 0:
            Contact.Update_Neighborhoods(dict_algorithm,dict_sample)
        Contact.Grains_Polyhedral_contact_Neighborhoods(dict_material,dict_sample)

        # Detection of contacts between grain and walls
        if dict_algorithm[&#39;i_DEM&#39;] % dict_algorithm[&#39;i_update_neighborhoods&#39;]  == 0:
            Contact_gw.Update_wall_Neighborhoods(dict_algorithm, dict_sample)
        Contact_gw.Grains_Polyhedral_Wall_contact_Neighborhood(dict_material,dict_sample)

        #Compute contact interactions (g-g and g-w)
        for contact in dict_sample[&#39;L_contact&#39;]:
            if dict_algorithm[&#39;Spring_type&#39;] == &#39;Ponctual&#39;:
                contact.DEM_2grains_Polyhedral_normal()
                contact.DEM_2grains_Polyhedral_tangential(dict_algorithm[&#39;dt_DEM&#39;])
            elif dict_algorithm[&#39;Spring_type&#39;] == &#39;Surface&#39;:
                contact.DEM_2grains_Polyhedral_normal_surface()
                contact.DEM_2grains_Polyhedral_tangential_surface(dict_algorithm[&#39;dt_DEM&#39;])
            else :
                simulation_report.write(&#39;Spring type not available !&#39;)
                raise ValueError(&#39;Spring type not available !&#39;)
        for contact in dict_sample[&#39;L_contact_gw&#39;] :
            if dict_algorithm[&#39;Spring_type&#39;] == &#39;Ponctual&#39;:
                contact.DEM_gw_Polyhedral_normal()
                contact.DEM_gw_Polyhedral_tangential(dict_algorithm[&#39;dt_DEM&#39;])
            else : #Surface must be coded for contact gw
                simulation_report.write(&#39;Spring type not available !&#39;)
                raise ValueError(&#39;Spring type not available !&#39;)

        #Move particles and trackers
        #Semi implicit euler scheme
        Ecin = 0
        Force_applied = 0
        for grain in dict_sample[&#39;L_g&#39;]:
            a_i = grain.f/grain.m
            v_i = grain.v + a_i*dict_algorithm[&#39;dt_DEM&#39;]
            dw_i = grain.mz/grain.inertia
            w_i = grain.w + dw_i*dict_algorithm[&#39;dt_DEM&#39;]
            grain.update_geometry_kinetic(v_i,a_i,w_i,dict_algorithm[&#39;dt_DEM&#39;]) #Move grains
            Ecin = Ecin + 0.5*grain.m*np.linalg.norm(grain.v)**2/len(dict_sample[&#39;L_g&#39;])
            Force_applied = Force_applied + np.linalg.norm(grain.f)/len(dict_sample[&#39;L_g&#39;])

        #Control the y_max to verify vertical confinement
        Owntools.Control_y_max_NR(dict_sample,dict_sollicitations)
        Owntools.Compute_k0(dict_sample,dict_sollicitations)
        #trackers
        dict_tracker[&#39;Ecin&#39;].append(Ecin)
        dict_tracker[&#39;Force_applied&#39;].append(Force_applied)
        dict_tracker[&#39;y_box_max&#39;].append(dict_sample[&#39;y_box_max&#39;])
        dict_tracker[&#39;Force_on_upper_wall&#39;].append(dict_sollicitations[&#39;Force_on_upper_wall&#39;])
        dict_tracker[&#39;k0_xmin&#39;].append(dict_sample[&#39;k0_xmin&#39;])
        dict_tracker[&#39;k0_xmax&#39;].append(dict_sample[&#39;k0_xmax&#39;])

        if dict_algorithm[&#39;i_DEM&#39;] %dict_algorithm[&#39;i_print_plot&#39;] == 0:
            print(&#39;\nPF &#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39; -&gt; i_DEM &#39;+str(dict_algorithm[&#39;i_DEM&#39;]+1)+&#39; / &#39;+str(dict_algorithm[&#39;i_DEM_stop&#39;]+1)+&#39; (max)&#39;)
            print(&#39;Ecin&#39;,int(Ecin),&#39;/&#39;,int(dict_algorithm[&#39;Ecin_stop&#39;]),&#39;(&#39;+str(int(100*Ecin/dict_algorithm[&#39;Ecin_stop&#39;])),&#39; %)&#39;)
            print(&#39;F_confinement&#39;,int(dict_sollicitations[&#39;Force_on_upper_wall&#39;]),&#39;/&#39;,int(dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]),&#39;(&#39;+str(int(100*dict_sollicitations[&#39;Force_on_upper_wall&#39;]/dict_sollicitations[&#39;Vertical_Confinement_Force&#39;])),&#39; %)&#39;)

            Owntools.save_DEM_tempo(dict_algorithm,dict_sample,dict_sollicitations,dict_tracker)

            if dict_algorithm[&#39;Debug_DEM&#39;] :
                Owntools.Debug_DEM_f(dict_algorithm, dict_sample)
                Write_txt(dict_algorithm,dict_sample)

        #-----------------------------------------------------------------------------
        # Stop conditions
        #-----------------------------------------------------------------------------

        if dict_algorithm[&#39;i_DEM&#39;] &gt;= dict_algorithm[&#39;i_DEM_stop&#39;] :
            DEM_loop_statut = False
            print(&#34;DEM loop stopped by too many iterations.&#34;)
            simulation_report.write(&#39;/!\ End of DEM steps with &#39;+str(dict_algorithm[&#39;i_DEM&#39;]+1)+&#39; iterations / &#39;+str(dict_algorithm[&#39;i_DEM_stop&#39;]+1)+&#39;/!\ \n&#39;)
        if Ecin &lt; dict_algorithm[&#39;Ecin_stop&#39;] and dict_algorithm[&#39;i_DEM&#39;] &gt; dict_algorithm[&#39;n_window_stop&#39;] and (dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]*0.95&lt;dict_sollicitations[&#39;Force_on_upper_wall&#39;] and dict_sollicitations[&#39;Force_on_upper_wall&#39;]&lt;dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]*1.05):
            k0_xmin_window = dict_tracker[&#39;k0_xmin&#39;][dict_algorithm[&#39;i_DEM&#39;]+1-dict_algorithm[&#39;n_window_stop&#39;]:dict_algorithm[&#39;i_DEM&#39;]+1]
            k0_xmax_window = dict_tracker[&#39;k0_xmax&#39;][dict_algorithm[&#39;i_DEM&#39;]+1-dict_algorithm[&#39;n_window_stop&#39;]:dict_algorithm[&#39;i_DEM&#39;]+1]
            y_box_max_window = dict_tracker[&#39;y_box_max&#39;][dict_algorithm[&#39;i_DEM&#39;]+1-dict_algorithm[&#39;n_window_stop&#39;]:dict_algorithm[&#39;i_DEM&#39;]+1]
            if max(k0_xmin_window) - min(k0_xmin_window) &lt; dict_algorithm[&#39;dk0_stop&#39;] and max(k0_xmax_window) - min(k0_xmax_window) &lt; dict_algorithm[&#39;dk0_stop&#39;] and max(y_box_max_window) - min(y_box_max_window) &lt; dict_algorithm[&#39;dy_box_max_stop&#39;]:
                DEM_loop_statut = False
                print(&#34;DEM loop stopped by steady state reached.&#34;)
                simulation_report.write(&#34;DEM loop stopped by steady state reached with &#34;+str(dict_algorithm[&#39;i_DEM&#39;]+1)+&#39; iterations / &#39;+str(dict_algorithm[&#39;i_DEM_stop&#39;]+1)+&#34;\n&#34;)

    #-----------------------------------------------------------------------------
    # Debugging at the end of DEM step
    #-----------------------------------------------------------------------------

    if dict_algorithm[&#39;Debug&#39;] :
        Owntools.Debug_configuration(dict_algorithm,dict_sample)
        Owntools.Debug_Trackers_DEM(dict_algorithm,dict_sollicitations,dict_tracker)
        Write_txt(dict_algorithm,dict_sample)
        Owntools.Plot_chain_force(dict_algorithm[&#39;i_PF&#39;],dict_algorithm[&#39;i_DEM&#39;])

        Owntools.save_DEM_final(dict_algorithm,dict_sample,dict_sollicitations,dict_tracker)

    #-----------------------------------------------------------------------------
    # Compute Vertical and horizontal sollicitations to compute k0
    #-----------------------------------------------------------------------------

    Owntools.Control_y_max_NR(dict_sample,dict_sollicitations)
    Owntools.Compute_k0(dict_sample,dict_sollicitations)

    simulation_report.write(&#39;k0_xmin : &#39;+str(round(dict_sample[&#39;k0_xmin&#39;],2))+&#39; / k0_xmax : &#39;+str(round(dict_sample[&#39;k0_xmax&#39;],2))+&#39;\n&#39;)

    #Update element in dict
    dict_tracker[&#39;k0_xmin_L&#39;].append(dict_sample[&#39;k0_xmin&#39;])
    dict_tracker[&#39;k0_xmax_L&#39;].append(dict_sample[&#39;k0_xmax&#39;])

    simulation_report.tac_tempo(datetime.now(),&#39;DEM loop &#39;+str(dict_algorithm[&#39;i_PF&#39;]))

    #-----------------------------------------------------------------------------
    # PF Simulation
    #-----------------------------------------------------------------------------

    simulation_report.tic_tempo(datetime.now())

    for grain in dict_sample[&#39;L_g&#39;]:
        if grain.dissolved :
            Create_i_AC_local(grain,dict_algorithm, dict_material, dict_sample,dict_sollicitations)
            os.system(&#39;mpiexec -n &#39;+str(dict_algorithm[&#39;np_proc&#39;])+&#39; ~/projects/moose/modules/combined/combined-opt -i PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;_g&#39;+str(grain.id)+&#39;.i&#39;)
            j_str = Owntools.Sort_Files(&#39;PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;_g&#39;+str(grain.id),dict_algorithm)
            grain.PFtoDEM_Multi_local(&#39;Output/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;_g&#39;+str(grain.id)+&#39;/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;_g&#39;+str(grain.id)+&#39;_other_&#39;+str(j_str),dict_algorithm)
            grain.Geometricstudy_local(dict_geometry,dict_sample,simulation_report)

    #Geometric study
    S_grains = 0
    S_grains_dissolvable = 0
    for grain in dict_sample[&#39;L_g&#39;]:
        S_grains = S_grains + grain.surface
        if grain.dissolved :
            S_grains_dissolvable = S_grains_dissolvable + grain.surface
    simulation_report.write(&#39;Total Surface &#39;+str(int(S_grains))+&#39; Âµm2\n&#39;)
    simulation_report.write(&#39;Total Surface dissolvable &#39;+str(int(S_grains_dissolvable))+&#39; Âµm2\n&#39;)

    # Tracker
    dict_tracker[&#39;t_L&#39;].append(dict_tracker[&#39;t_L&#39;][-1] + dict_algorithm[&#39;dt_PF&#39;]*dict_algorithm[&#39;n_t_PF&#39;])
    dict_tracker[&#39;S_grains_L&#39;].append(S_grains)
    dict_tracker[&#39;S_dissolved_L&#39;].append(dict_tracker[&#39;S_grains_L&#39;][0]-S_grains)
    dict_tracker[&#39;S_dissolved_perc_L&#39;].append((dict_tracker[&#39;S_grains_L&#39;][0]-S_grains)/(dict_tracker[&#39;S_grains_L&#39;][0])*100)
    dict_tracker[&#39;n_grains_L&#39;].append(len(dict_sample[&#39;L_g&#39;]))
    dict_tracker[&#39;S_grains_dissolvable_L&#39;].append(S_grains_dissolvable)
    dict_tracker[&#39;S_dissolved_perc_dissolvable_L&#39;].append((dict_tracker[&#39;S_grains_dissolvable_L&#39;][0]-S_grains_dissolvable)/(dict_tracker[&#39;S_grains_dissolvable_L&#39;][0])*100)

    simulation_report.tac_tempo(datetime.now(),&#39;PF iteration &#39;+str(dict_algorithm[&#39;i_PF&#39;]))

    #-----------------------------------------------------------------------------
    # Reinitialisation of contact for the next step
    #-----------------------------------------------------------------------------

    for contact in dict_sample[&#39;L_contact&#39;]:
        contact.init_contact(dict_sample[&#39;L_g&#39;])
    for contact in dict_sample[&#39;L_contact_gw&#39;]:
        contact.init_contact_gw(dict_sample[&#39;L_g&#39;])

    #-----------------------------------------------------------------------------
    # Print Grains configuration
    #-----------------------------------------------------------------------------

    if dict_algorithm[&#39;Debug&#39;] :
        Owntools.Debug_configuration(dict_algorithm,dict_sample)
        #Trackers
        Owntools.Debug_Trackers(dict_tracker)

    #-----------------------------------------------------------------------------
    # Save tempo
    #-----------------------------------------------------------------------------

    if dict_algorithm[&#39;SaveData&#39;] :
        Owntools.save_tempo(dict_algorithm,dict_tracker)
        Owntools.save_dicts(dict_algorithm, dict_geometry, dict_material, dict_sample, dict_sollicitations, dict_tracker)
        shutil.copy(&#39;Debug/Report.txt&#39;,&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/Report_&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_tempo.txt&#39;)

#-------------------------------------------------------------------------------

def close_simulation(dict_algorithm, dict_tracker, simulation_report):
    &#39;&#39;&#39;
    Close the PFDEM.

        Input :
            an algorithm dictionnary (a dict)
            a tracker dictionnary (a dict)
            a simulation report (a Report)
        Output :
            Nothing but the dictionnaries and the report are updated
    &#39;&#39;&#39;
    # toc
    simulation_report.end(datetime.now())

    # Debugging and Output
    if dict_algorithm[&#39;Debug&#39;] :

        #Making movies
        Owntools.make_mp4()
        #Trackers
        Owntools.Debug_Trackers(dict_tracker)

    #Saving data
    if dict_algorithm[&#39;SaveData&#39;] :

        #clean memory
        if dict_algorithm[&#39;clean_memory&#39;]:
            shutil.rmtree(&#39;Data&#39;)
            shutil.rmtree(&#39;Input&#39;)
            shutil.rmtree(&#39;Output&#39;)

        Owntools.save_final(dict_algorithm,dict_tracker)
        name_actual_folder = os.path.dirname(os.path.realpath(__file__))
        shutil.copytree(name_actual_folder, &#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;name_folder&#39;])
        os.remove(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/User_&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_tempo.txt&#39;)
        os.remove(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/Report_&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_tempo.txt&#39;)
        os.remove(dict_algorithm[&#39;name_folder&#39;]+&#39;_save_dicts&#39;)

#-------------------------------------------------------------------------------

if &#39;__main__&#39; == __name__:
    #-------------------------------------------------------------------------------
    #Plan simulation
    #-------------------------------------------------------------------------------

    if Path(&#39;Debug&#39;).exists():
        shutil.rmtree(&#39;Debug&#39;)
    if Path(&#39;Input&#39;).exists():
        shutil.rmtree(&#39;Input&#39;)
    if Path(&#39;Output&#39;).exists():
        shutil.rmtree(&#39;Output&#39;)
    if Path(&#39;Data&#39;).exists():
        shutil.rmtree(&#39;Data&#39;)

    os.mkdir(&#39;Debug&#39;)
    os.mkdir(&#39;Debug/DEM_ite&#39;)
    os.mkdir(&#39;Debug/DEM_ite/Init&#39;)
    os.mkdir(&#39;Input&#39;)
    os.mkdir(&#39;Output&#39;)
    os.mkdir(&#39;Data&#39;)

    #-------------------------------------------------------------------------------
    # tic
    #-------------------------------------------------------------------------------

    simulation_report = Report.Report(&#39;Debug/Report&#39;,datetime.now())

    #-------------------------------------------------------------------------------
    #Initial conditions
    #-------------------------------------------------------------------------------

    simulation_report.tic_tempo(datetime.now())

    dict_algorithm, dict_geometry, dict_ic, dict_material, dict_sample, dict_sollicitations = User.All_parameters()

    if dict_algorithm[&#39;Debug&#39;] or dict_algorithm[&#39;Debug_DEM&#39;] :
        simulation_report.write(&#39;This simulation can be debugged\n&#39;)
    if dict_algorithm[&#39;SaveData&#39;] :
        if not Path(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]).exists():
            os.mkdir(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;])
        simulation_report.write(&#39;This simulation is saved\n&#39;)
        i_run = 1
        folderpath = Path(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;template_simulation_name&#39;]+str(i_run))
        while folderpath.exists():
            i_run = i_run + 1
            folderpath = Path(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;template_simulation_name&#39;]+str(i_run))

        #add element in dict
        dict_algorithm[&#39;name_folder&#39;] = dict_algorithm[&#39;template_simulation_name&#39;]+str(i_run)

        #tempo save of the user file
        shutil.copy(&#39;User.py&#39;,&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/User_&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_tempo.txt&#39;)

    if dict_algorithm[&#39;SaveData&#39;] or dict_algorithm[&#39;Debug&#39;] or dict_algorithm[&#39;Debug_DEM&#39;]:
        simulation_report.write(&#39;\n&#39;)

    #Creation of the grain (without PF)
    simulation_report.write_and_print(&#39;Creation of the grains\n&#39;,&#39;\nCREATION OF THE GRAINS\n&#39;)
    LG_tempo(dict_algorithm, dict_geometry, dict_ic, dict_material, dict_sample, dict_sollicitations, simulation_report)

    simulation_report.tac_tempo(datetime.now(),&#39;Initialisation&#39;)

    #-------------------------------------------------------------------------------
    #Creation of polygonal particles
    #-------------------------------------------------------------------------------

    simulation_report.tic_tempo(datetime.now())

    # Creation of the real list of grains
    From_LG_tempo_to_usable(dict_ic, dict_geometry, dict_material, dict_sample)#creation pf the dissolution .txt

    simulation_report.tac_tempo(datetime.now(),&#39;Creation of polygonal particles&#39;)

    #-------------------------------------------------------------------------------
    #Distribution etai
    #-------------------------------------------------------------------------------

    simulation_report.tic_tempo(datetime.now())

    #Saving the grain surface
    S_grains_dissolvable = 0
    S_grains = 0
    for grain in dict_sample[&#39;L_g&#39;]:
        S_grains = S_grains + grain.surface
        if grain.dissolved :
            S_grains_dissolvable = S_grains_dissolvable + grain.surface
    simulation_report.write(&#39;Total Surface &#39;+str(round(S_grains,0))+&#39; Âµm2\n&#39;)
    simulation_report.write(&#39;Total Surface dissolvable &#39;+str(round(S_grains_dissolvable,0))+&#39; Âµm2\n&#39;)
    simulation_report.tac_tempo(datetime.now(),&#39;Dissolution distribution&#39;)

    #-------------------------------------------------------------------------------
    #Main
    #-------------------------------------------------------------------------------

    #Tracker and create an new dict
    dict_tracker = {
        &#39;t_L&#39; : [0],
        &#39;S_grains_L&#39; : [],
        &#39;S_grains_dissolvable_L&#39; : [],
        &#39;S_dissolved_L&#39; : [],
        &#39;S_dissolved_perc_L&#39; : [],
        &#39;S_dissolved_perc_dissolvable_L&#39; : [],
        &#39;n_grains_L&#39; : [len(dict_sample[&#39;L_g&#39;])],
        &#39;k0_xmin_L&#39; : [],
        &#39;k0_xmax_L&#39; : []
    }

    # Preparation and add elements in dicts
    dict_algorithm[&#39;i_PF&#39;] = 0
    dict_sample[&#39;L_contact_gw&#39;] = []
    dict_sample[&#39;L_ij_contact_gw&#39;] = []
    dict_sample[&#39;id_contact_gw&#39;] = 0
    dict_sample[&#39;L_contact&#39;] = []
    dict_sample[&#39;L_ij_contact&#39;] = []
    dict_sample[&#39;id_contact&#39;] = 0

    if dict_algorithm[&#39;Debug&#39;] :
        Owntools.Debug_configuration(dict_algorithm,dict_sample)

    while not User.Criteria_StopSimulation(dict_algorithm):

        main_iteration(dict_algorithm, dict_geometry, dict_material, dict_sollicitations, dict_sample, dict_tracker, simulation_report)

    #-------------------------------------------------------------------------------
    # close simulation
    #-------------------------------------------------------------------------------

    close_simulation(dict_algorithm, dict_tracker, simulation_report)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="main.close_simulation"><code class="name flex">
<span>def <span class="ident">close_simulation</span></span>(<span>dict_algorithm, dict_tracker, simulation_report)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the PFDEM.</p>
<pre><code>Input :
    an algorithm dictionnary (a dict)
    a tracker dictionnary (a dict)
    a simulation report (a Report)
Output :
    Nothing but the dictionnaries and the report are updated
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_simulation(dict_algorithm, dict_tracker, simulation_report):
    &#39;&#39;&#39;
    Close the PFDEM.

        Input :
            an algorithm dictionnary (a dict)
            a tracker dictionnary (a dict)
            a simulation report (a Report)
        Output :
            Nothing but the dictionnaries and the report are updated
    &#39;&#39;&#39;
    # toc
    simulation_report.end(datetime.now())

    # Debugging and Output
    if dict_algorithm[&#39;Debug&#39;] :

        #Making movies
        Owntools.make_mp4()
        #Trackers
        Owntools.Debug_Trackers(dict_tracker)

    #Saving data
    if dict_algorithm[&#39;SaveData&#39;] :

        #clean memory
        if dict_algorithm[&#39;clean_memory&#39;]:
            shutil.rmtree(&#39;Data&#39;)
            shutil.rmtree(&#39;Input&#39;)
            shutil.rmtree(&#39;Output&#39;)

        Owntools.save_final(dict_algorithm,dict_tracker)
        name_actual_folder = os.path.dirname(os.path.realpath(__file__))
        shutil.copytree(name_actual_folder, &#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;name_folder&#39;])
        os.remove(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/User_&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_tempo.txt&#39;)
        os.remove(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/Report_&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_tempo.txt&#39;)
        os.remove(dict_algorithm[&#39;name_folder&#39;]+&#39;_save_dicts&#39;)</code></pre>
</details>
</dd>
<dt id="main.main_iteration"><code class="name flex">
<span>def <span class="ident">main_iteration</span></span>(<span>dict_algorithm, dict_geometry, dict_material, dict_sollicitations, dict_sample, dict_tracker, simulation_report)</span>
</code></dt>
<dd>
<div class="desc"><p>Description of one PDEM iteration.</p>
<p>The iteration is composed by a DEM step (to obtain a steady state configuration) and a PF step (to obtain dissolution and precipitation).</p>
<pre><code>Input :
    an algorithm dictionnary (a dict)
    a geometry dictionnary (a dict)
    a material dictionnary (a dict)
    a sollicitation dictionnary (a dict)
    a sample dictionnary (a dict)
    a tracker dictionnary (a dict)
    a simulation report (a Report)
Output :
    Nothing but the dictionnaies and the report are updated
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main_iteration(dict_algorithm, dict_geometry, dict_material, dict_sollicitations, dict_sample, dict_tracker, simulation_report):
    &#39;&#39;&#39;
    Description of one PDEM iteration.

    The iteration is composed by a DEM step (to obtain a steady state configuration) and a PF step (to obtain dissolution and precipitation).

        Input :
            an algorithm dictionnary (a dict)
            a geometry dictionnary (a dict)
            a material dictionnary (a dict)
            a sollicitation dictionnary (a dict)
            a sample dictionnary (a dict)
            a tracker dictionnary (a dict)
            a simulation report (a Report)
        Output :
            Nothing but the dictionnaies and the report are updated
    &#39;&#39;&#39;
    # update element in dict
    dict_algorithm[&#39;i_PF&#39;] = dict_algorithm[&#39;i_PF&#39;] + 1

    simulation_report.write_and_print(&#39;\nIteration &#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39; / &#39;+str(dict_algorithm[&#39;n_t_PFDEM&#39;])+&#39;\n&#39;,&#39;\nITERATION PF &#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39; / &#39;+str(dict_algorithm[&#39;n_t_PFDEM&#39;])+&#39;\n&#39;)

    #prepare iteration
    if Path(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])).exists():
        shutil.rmtree(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;]))
    os.mkdir(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;]))
    os.mkdir(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/txt&#39;)
    os.mkdir(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/png&#39;)

    if dict_algorithm[&#39;MovePF_selector&#39;] == &#39;Interpolation&#39;:
        # Saving to compute a rigid body motion
        L_center_g = []
        for grain in dict_sample[&#39;L_g&#39;]:
            L_center_g.append(grain.center.copy())

    # Compute kinetic energy criteria
    Ecin_stop = 0
    for grain in dict_sample[&#39;L_g&#39;]:
        Ecin_stop = Ecin_stop + 0.5*grain.m*(dict_algorithm[&#39;Ecin_ratio&#39;]*grain.r_mean/dict_algorithm[&#39;dt_DEM&#39;])**2/len(dict_sample[&#39;L_g&#39;])

    #Update element in dict
    dict_algorithm[&#39;Ecin_stop&#39;] = Ecin_stop

    #Trackers and add element in dict
    dict_tracker[&#39;Ecin&#39;] = []
    dict_tracker[&#39;Force_applied&#39;] = []
    dict_tracker[&#39;k0_xmin&#39;] = []
    dict_tracker[&#39;k0_xmax&#39;] = []
    dict_tracker[&#39;y_box_max&#39;] = [dict_sample[&#39;y_box_max&#39;]]
    dict_tracker[&#39;Force_on_upper_wall&#39;] = []

    dict_algorithm[&#39;i_DEM&#39;] = - 1
    DEM_loop_statut = True
    simulation_report.write(&#39;\n&#39;)
    simulation_report.tic_tempo(datetime.now())

    #-----------------------------------------------------------------------------
    # DEM iteration
    #-----------------------------------------------------------------------------

    while DEM_loop_statut :
        # update element in dict
        dict_algorithm[&#39;i_DEM&#39;] = dict_algorithm[&#39;i_DEM&#39;] + 1

        for grain in dict_sample[&#39;L_g&#39;]:
            grain.init_f_control(dict_sollicitations)

        # Detection of contacts between grains
        if dict_algorithm[&#39;i_DEM&#39;] % dict_algorithm[&#39;i_update_neighborhoods&#39;]  == 0:
            Contact.Update_Neighborhoods(dict_algorithm,dict_sample)
        Contact.Grains_Polyhedral_contact_Neighborhoods(dict_material,dict_sample)

        # Detection of contacts between grain and walls
        if dict_algorithm[&#39;i_DEM&#39;] % dict_algorithm[&#39;i_update_neighborhoods&#39;]  == 0:
            Contact_gw.Update_wall_Neighborhoods(dict_algorithm, dict_sample)
        Contact_gw.Grains_Polyhedral_Wall_contact_Neighborhood(dict_material,dict_sample)

        #Compute contact interactions (g-g and g-w)
        for contact in dict_sample[&#39;L_contact&#39;]:
            if dict_algorithm[&#39;Spring_type&#39;] == &#39;Ponctual&#39;:
                contact.DEM_2grains_Polyhedral_normal()
                contact.DEM_2grains_Polyhedral_tangential(dict_algorithm[&#39;dt_DEM&#39;])
            elif dict_algorithm[&#39;Spring_type&#39;] == &#39;Surface&#39;:
                contact.DEM_2grains_Polyhedral_normal_surface()
                contact.DEM_2grains_Polyhedral_tangential_surface(dict_algorithm[&#39;dt_DEM&#39;])
            else :
                simulation_report.write(&#39;Spring type not available !&#39;)
                raise ValueError(&#39;Spring type not available !&#39;)
        for contact in dict_sample[&#39;L_contact_gw&#39;] :
            if dict_algorithm[&#39;Spring_type&#39;] == &#39;Ponctual&#39;:
                contact.DEM_gw_Polyhedral_normal()
                contact.DEM_gw_Polyhedral_tangential(dict_algorithm[&#39;dt_DEM&#39;])
            else : #Surface must be coded for contact gw
                simulation_report.write(&#39;Spring type not available !&#39;)
                raise ValueError(&#39;Spring type not available !&#39;)

        #Move particles and trackers
        #Semi implicit euler scheme
        Ecin = 0
        Force_applied = 0
        for grain in dict_sample[&#39;L_g&#39;]:
            a_i = grain.f/grain.m
            v_i = grain.v + a_i*dict_algorithm[&#39;dt_DEM&#39;]
            dw_i = grain.mz/grain.inertia
            w_i = grain.w + dw_i*dict_algorithm[&#39;dt_DEM&#39;]
            grain.update_geometry_kinetic(v_i,a_i,w_i,dict_algorithm[&#39;dt_DEM&#39;]) #Move grains
            Ecin = Ecin + 0.5*grain.m*np.linalg.norm(grain.v)**2/len(dict_sample[&#39;L_g&#39;])
            Force_applied = Force_applied + np.linalg.norm(grain.f)/len(dict_sample[&#39;L_g&#39;])

        #Control the y_max to verify vertical confinement
        Owntools.Control_y_max_NR(dict_sample,dict_sollicitations)
        Owntools.Compute_k0(dict_sample,dict_sollicitations)
        #trackers
        dict_tracker[&#39;Ecin&#39;].append(Ecin)
        dict_tracker[&#39;Force_applied&#39;].append(Force_applied)
        dict_tracker[&#39;y_box_max&#39;].append(dict_sample[&#39;y_box_max&#39;])
        dict_tracker[&#39;Force_on_upper_wall&#39;].append(dict_sollicitations[&#39;Force_on_upper_wall&#39;])
        dict_tracker[&#39;k0_xmin&#39;].append(dict_sample[&#39;k0_xmin&#39;])
        dict_tracker[&#39;k0_xmax&#39;].append(dict_sample[&#39;k0_xmax&#39;])

        if dict_algorithm[&#39;i_DEM&#39;] %dict_algorithm[&#39;i_print_plot&#39;] == 0:
            print(&#39;\nPF &#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39; -&gt; i_DEM &#39;+str(dict_algorithm[&#39;i_DEM&#39;]+1)+&#39; / &#39;+str(dict_algorithm[&#39;i_DEM_stop&#39;]+1)+&#39; (max)&#39;)
            print(&#39;Ecin&#39;,int(Ecin),&#39;/&#39;,int(dict_algorithm[&#39;Ecin_stop&#39;]),&#39;(&#39;+str(int(100*Ecin/dict_algorithm[&#39;Ecin_stop&#39;])),&#39; %)&#39;)
            print(&#39;F_confinement&#39;,int(dict_sollicitations[&#39;Force_on_upper_wall&#39;]),&#39;/&#39;,int(dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]),&#39;(&#39;+str(int(100*dict_sollicitations[&#39;Force_on_upper_wall&#39;]/dict_sollicitations[&#39;Vertical_Confinement_Force&#39;])),&#39; %)&#39;)

            Owntools.save_DEM_tempo(dict_algorithm,dict_sample,dict_sollicitations,dict_tracker)

            if dict_algorithm[&#39;Debug_DEM&#39;] :
                Owntools.Debug_DEM_f(dict_algorithm, dict_sample)
                Write_txt(dict_algorithm,dict_sample)

        #-----------------------------------------------------------------------------
        # Stop conditions
        #-----------------------------------------------------------------------------

        if dict_algorithm[&#39;i_DEM&#39;] &gt;= dict_algorithm[&#39;i_DEM_stop&#39;] :
            DEM_loop_statut = False
            print(&#34;DEM loop stopped by too many iterations.&#34;)
            simulation_report.write(&#39;/!\ End of DEM steps with &#39;+str(dict_algorithm[&#39;i_DEM&#39;]+1)+&#39; iterations / &#39;+str(dict_algorithm[&#39;i_DEM_stop&#39;]+1)+&#39;/!\ \n&#39;)
        if Ecin &lt; dict_algorithm[&#39;Ecin_stop&#39;] and dict_algorithm[&#39;i_DEM&#39;] &gt; dict_algorithm[&#39;n_window_stop&#39;] and (dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]*0.95&lt;dict_sollicitations[&#39;Force_on_upper_wall&#39;] and dict_sollicitations[&#39;Force_on_upper_wall&#39;]&lt;dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]*1.05):
            k0_xmin_window = dict_tracker[&#39;k0_xmin&#39;][dict_algorithm[&#39;i_DEM&#39;]+1-dict_algorithm[&#39;n_window_stop&#39;]:dict_algorithm[&#39;i_DEM&#39;]+1]
            k0_xmax_window = dict_tracker[&#39;k0_xmax&#39;][dict_algorithm[&#39;i_DEM&#39;]+1-dict_algorithm[&#39;n_window_stop&#39;]:dict_algorithm[&#39;i_DEM&#39;]+1]
            y_box_max_window = dict_tracker[&#39;y_box_max&#39;][dict_algorithm[&#39;i_DEM&#39;]+1-dict_algorithm[&#39;n_window_stop&#39;]:dict_algorithm[&#39;i_DEM&#39;]+1]
            if max(k0_xmin_window) - min(k0_xmin_window) &lt; dict_algorithm[&#39;dk0_stop&#39;] and max(k0_xmax_window) - min(k0_xmax_window) &lt; dict_algorithm[&#39;dk0_stop&#39;] and max(y_box_max_window) - min(y_box_max_window) &lt; dict_algorithm[&#39;dy_box_max_stop&#39;]:
                DEM_loop_statut = False
                print(&#34;DEM loop stopped by steady state reached.&#34;)
                simulation_report.write(&#34;DEM loop stopped by steady state reached with &#34;+str(dict_algorithm[&#39;i_DEM&#39;]+1)+&#39; iterations / &#39;+str(dict_algorithm[&#39;i_DEM_stop&#39;]+1)+&#34;\n&#34;)

    #-----------------------------------------------------------------------------
    # Debugging at the end of DEM step
    #-----------------------------------------------------------------------------

    if dict_algorithm[&#39;Debug&#39;] :
        Owntools.Debug_configuration(dict_algorithm,dict_sample)
        Owntools.Debug_Trackers_DEM(dict_algorithm,dict_sollicitations,dict_tracker)
        Write_txt(dict_algorithm,dict_sample)
        Owntools.Plot_chain_force(dict_algorithm[&#39;i_PF&#39;],dict_algorithm[&#39;i_DEM&#39;])

        Owntools.save_DEM_final(dict_algorithm,dict_sample,dict_sollicitations,dict_tracker)

    #-----------------------------------------------------------------------------
    # Compute Vertical and horizontal sollicitations to compute k0
    #-----------------------------------------------------------------------------

    Owntools.Control_y_max_NR(dict_sample,dict_sollicitations)
    Owntools.Compute_k0(dict_sample,dict_sollicitations)

    simulation_report.write(&#39;k0_xmin : &#39;+str(round(dict_sample[&#39;k0_xmin&#39;],2))+&#39; / k0_xmax : &#39;+str(round(dict_sample[&#39;k0_xmax&#39;],2))+&#39;\n&#39;)

    #Update element in dict
    dict_tracker[&#39;k0_xmin_L&#39;].append(dict_sample[&#39;k0_xmin&#39;])
    dict_tracker[&#39;k0_xmax_L&#39;].append(dict_sample[&#39;k0_xmax&#39;])

    simulation_report.tac_tempo(datetime.now(),&#39;DEM loop &#39;+str(dict_algorithm[&#39;i_PF&#39;]))

    #-----------------------------------------------------------------------------
    # PF Simulation
    #-----------------------------------------------------------------------------

    simulation_report.tic_tempo(datetime.now())

    for grain in dict_sample[&#39;L_g&#39;]:
        if grain.dissolved :
            Create_i_AC_local(grain,dict_algorithm, dict_material, dict_sample,dict_sollicitations)
            os.system(&#39;mpiexec -n &#39;+str(dict_algorithm[&#39;np_proc&#39;])+&#39; ~/projects/moose/modules/combined/combined-opt -i PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;_g&#39;+str(grain.id)+&#39;.i&#39;)
            j_str = Owntools.Sort_Files(&#39;PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;_g&#39;+str(grain.id),dict_algorithm)
            grain.PFtoDEM_Multi_local(&#39;Output/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;_g&#39;+str(grain.id)+&#39;/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;_g&#39;+str(grain.id)+&#39;_other_&#39;+str(j_str),dict_algorithm)
            grain.Geometricstudy_local(dict_geometry,dict_sample,simulation_report)

    #Geometric study
    S_grains = 0
    S_grains_dissolvable = 0
    for grain in dict_sample[&#39;L_g&#39;]:
        S_grains = S_grains + grain.surface
        if grain.dissolved :
            S_grains_dissolvable = S_grains_dissolvable + grain.surface
    simulation_report.write(&#39;Total Surface &#39;+str(int(S_grains))+&#39; Âµm2\n&#39;)
    simulation_report.write(&#39;Total Surface dissolvable &#39;+str(int(S_grains_dissolvable))+&#39; Âµm2\n&#39;)

    # Tracker
    dict_tracker[&#39;t_L&#39;].append(dict_tracker[&#39;t_L&#39;][-1] + dict_algorithm[&#39;dt_PF&#39;]*dict_algorithm[&#39;n_t_PF&#39;])
    dict_tracker[&#39;S_grains_L&#39;].append(S_grains)
    dict_tracker[&#39;S_dissolved_L&#39;].append(dict_tracker[&#39;S_grains_L&#39;][0]-S_grains)
    dict_tracker[&#39;S_dissolved_perc_L&#39;].append((dict_tracker[&#39;S_grains_L&#39;][0]-S_grains)/(dict_tracker[&#39;S_grains_L&#39;][0])*100)
    dict_tracker[&#39;n_grains_L&#39;].append(len(dict_sample[&#39;L_g&#39;]))
    dict_tracker[&#39;S_grains_dissolvable_L&#39;].append(S_grains_dissolvable)
    dict_tracker[&#39;S_dissolved_perc_dissolvable_L&#39;].append((dict_tracker[&#39;S_grains_dissolvable_L&#39;][0]-S_grains_dissolvable)/(dict_tracker[&#39;S_grains_dissolvable_L&#39;][0])*100)

    simulation_report.tac_tempo(datetime.now(),&#39;PF iteration &#39;+str(dict_algorithm[&#39;i_PF&#39;]))

    #-----------------------------------------------------------------------------
    # Reinitialisation of contact for the next step
    #-----------------------------------------------------------------------------

    for contact in dict_sample[&#39;L_contact&#39;]:
        contact.init_contact(dict_sample[&#39;L_g&#39;])
    for contact in dict_sample[&#39;L_contact_gw&#39;]:
        contact.init_contact_gw(dict_sample[&#39;L_g&#39;])

    #-----------------------------------------------------------------------------
    # Print Grains configuration
    #-----------------------------------------------------------------------------

    if dict_algorithm[&#39;Debug&#39;] :
        Owntools.Debug_configuration(dict_algorithm,dict_sample)
        #Trackers
        Owntools.Debug_Trackers(dict_tracker)

    #-----------------------------------------------------------------------------
    # Save tempo
    #-----------------------------------------------------------------------------

    if dict_algorithm[&#39;SaveData&#39;] :
        Owntools.save_tempo(dict_algorithm,dict_tracker)
        Owntools.save_dicts(dict_algorithm, dict_geometry, dict_material, dict_sample, dict_sollicitations, dict_tracker)
        shutil.copy(&#39;Debug/Report.txt&#39;,&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/Report_&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_tempo.txt&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="main.close_simulation" href="#main.close_simulation">close_simulation</a></code></li>
<li><code><a title="main.main_iteration" href="#main.main_iteration">main_iteration</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>