<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Owntools API documentation</title>
<meta name="description" content="@author: Alexandre Sac--Morane
alexandre.sac-morane@uclouvain.be â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Owntools</code></h1>
</header>
<section id="section-intro">
<p>@author: Alexandre Sac&ndash;Morane
alexandre.sac-morane@uclouvain.be</p>
<p>This file contains the different functions used in the simulation.
This tools can be : - a little function
- a plot to debug or print something
- a postprocess</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
@author: Alexandre Sac--Morane
alexandre.sac-morane@uclouvain.be

This file contains the different functions used in the simulation.
This tools can be : - a little function
                    - a plot to debug or print something
                    - a postprocess
&#34;&#34;&#34;

#-------------------------------------------------------------------------------
#Librairies
#-------------------------------------------------------------------------------

import numpy as np
import math
import Report
import matplotlib.pyplot as plt
import os
import shutil
from pathlib import Path
import pickle
from pathlib import Path
from datetime import datetime
import random
import imageio
import Contact
import Contact_gw
import Grain

#-------------------------------------------------------------------------------

class Grain_pp:

    def __init__(self, Id, Dissolved, Center, Coordinate_x, Coordinate_y):
        &#34;&#34;&#34;
        Defining a grain for the postprocess

            Input :
                itself (a grain_pp)
                an id (a int)
                a Boolean to know if the grain is dissolvable (a Boolean)
                a center (a 1 x 2 numpy array)
                two lists of vertices coordinates x and y (two lists)
            Output :
                Nothing, but a post process grain is generated
        &#34;&#34;&#34;
        self.id = Id
        self.dissolved = Dissolved
        self.center = Center
        self.coordinate_x = Coordinate_x
        self.coordinate_y = Coordinate_y

#-------------------------------------------------------------------------------

class Contact_pp:

    def __init__(self, Id_g1, Id_g2, L_g, Normal):
        &#34;&#34;&#34;
        Defining a contact grain - grain for the postprocess.

            Input :
                itself (a contact_pp)
                the ids of the grains (two int)
                a list of post process grains (a list)
                the value of normal reaction of the contact (a float)
            Output :
                Nothing, but a post process contact grain - grain is generated
        &#34;&#34;&#34;
        for g in L_g:
            if g.id == Id_g1:
                self.g1 = g
            elif g.id == Id_g2:
                self.g2 = g
        self.normal = Normal

    def plot(self, normal_ref):
        &#34;&#34;&#34;
        Prepare the chain force plot.

            Input :
                itself (a contact_pp)
                a reference value (a float)
            Output :
                Nothing, but the post process contact gets the ratio of the normal force with the reference value as a new attribut (a float)
        &#34;&#34;&#34;
        L_x = [self.g1.center[0], self.g2.center[0]]
        L_y = [self.g1.center[1], self.g2.center[1]]
        ratio_normal = self.normal/normal_ref
        return L_x, L_y, ratio_normal

#-------------------------------------------------------------------------------

class Contact_gw_pp:

    def __init__(self, Id_g, L_g, Nature, Limit, Normal):
        &#34;&#34;&#34;
        Defining a contact grain-wall for the postprocess.

            Input :
                itself (a contact_gw_pp)
                a id of the grain (a float)
                the list of the post process grain (a list)
                the nature of the wall (a string)
                the value of normal reaction of the contact (a float)
        &#34;&#34;&#34;
        for g in L_g:
            if g.id == Id_g:
                self.g = g
        self.nature = Nature
        self.limit = Limit
        self.normal = Normal

    def plot(self, normal_ref):
        &#34;&#34;&#34;
        Prepare the chain force plot.

            Input :
                itself (a contact_gw_pp)
                a reference value (a float)
            Output :
                Nothing, but the post process contact gets the ratio of the normal force with the reference value as a new attribut (a float)
        &#34;&#34;&#34;
        if self.nature == &#39;gwx_min&#39; or self.nature == &#39;gwx_max&#39;:
            virtual_center = [self.limit, self.g.center[1]]
        elif self.nature == &#39;gwy_min&#39; or self.nature == &#39;gwy_max&#39;:
            virtual_center = [ self.g.center[0], self.limit]
        L_x = [self.g.center[0], virtual_center[0]]
        L_y = [self.g.center[1], virtual_center[1]]
        ratio_normal = self.normal/normal_ref
        return L_x, L_y, ratio_normal

#-------------------------------------------------------------------------------
#functions
#-------------------------------------------------------------------------------

def index_to_str(j):
      &#34;&#34;&#34;
      Convert an integer to a float with 3 components

        Input :
            an integer (a int)
        Output :
            a string (a string)
      &#34;&#34;&#34;
      if j &lt; 10:
          j_str = &#39;00&#39;+str(j)
      elif 10 &lt;= j and j &lt; 100:
          j_str = &#39;0&#39;+str(j)
      else :
          j_str = str(j)
      return j_str

#-------------------------------------------------------------------------------

def Stop_Debug(simulation_report):
      &#34;&#34;&#34;
      Stop simulation for debugging.

        Input :
            the simulation report (a report)
        Output :
            Nothing, but simulations stops
      &#34;&#34;&#34;
      simulation_report.write(&#39;Stop because after it is not corrected !\n&#39;)
      simulation_report.end(datetime.now())
      raise ValueError(&#39;Stop because after it is not corrected !&#39;)

#-------------------------------------------------------------------------------

def Debug_DEM_f(dict_algorithm, dict_sample):
    &#34;&#34;&#34;
    Plot the configuration of the grains during a DEM step.

        Input:
            an algorithm dictionnary (a dict)
            a sample dictionnary (a dict)
        Output :
            Nothing, but a .png file is generated (a file)
    &#34;&#34;&#34;
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    #load data needed
    x_min = dict_sample[&#39;x_box_min&#39;]
    x_max = dict_sample[&#39;x_box_max&#39;]
    y_min = dict_sample[&#39;y_box_min&#39;]
    y_max = dict_sample[&#39;y_box_max&#39;]
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

    fig = plt.figure(1,figsize=(16,9.12))
    for grain in dict_sample[&#39;L_g&#39;]:
        plt.plot(grain.l_border_x,grain.l_border_y,&#39;k&#39;)
    for contact in dict_sample[&#39;L_contact&#39;] :
        alpha = (contact.g1.r_mean*0.1 + contact.g2.r_mean*0.1)/2
        M = (contact.g1.center + contact.g2.center)/2
        plt.plot([M[0], M[0]+contact.pc_normal[0]*alpha], [M[1], M[1]+contact.pc_normal[1]*alpha],&#39;k&#39;)
        plt.plot([M[0], M[0]+contact.pc_tangential[0]*alpha], [M[1], M[1]+contact.pc_tangential[1]*alpha],&#39;k&#39;)
    for contact in dict_sample[&#39;L_contact_gw&#39;] :
        alpha = contact.g.r_mean*0.1
        if contact.nature == &#39;gwy_min&#39; or contact.nature == &#39;gwy_max&#39;:
            M = np.array([contact.g.center[0],contact.limit])
        elif contact.nature == &#39;gwx_min&#39; or contact.nature == &#39;gwx_max&#39;:
            M = np.array([contact.limit,contact.g.center[1]])
        plt.plot([M[0], M[0]+contact.nwg[0]*alpha], [M[1], M[1]+contact.nwg[1]*alpha],&#39;k&#39;)
        plt.plot([M[0], M[0]+contact.twg[0]*alpha], [M[1], M[1]+contact.twg[1]*alpha],&#39;k&#39;)
    plt.plot([x_min,x_max,x_max,x_min,x_min],[y_min,y_min,y_max,y_max,y_min],&#39;k&#39;)
    plt.axis(&#34;equal&#34;)
    fig.savefig(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/png/Config_&#39;+str(dict_algorithm[&#39;i_DEM&#39;])+&#39;.png&#39;)
    plt.close(1)

#-------------------------------------------------------------------------------

def Debug_configuration(dict_algorithm,dict_sample):
  &#34;&#34;&#34;
  Plot the configuration of the grains before / after the DEM step.

        Input:
            an algorithm dictionnary (a dict)
            a sample dictionnary (a dict)
        Output :
            Nothing, but a .png file is generated (a file)
  &#34;&#34;&#34;
  #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
  #load data needed
  x_min = dict_sample[&#39;x_box_min&#39;]
  x_max = dict_sample[&#39;x_box_max&#39;]
  y_min = dict_sample[&#39;y_box_min&#39;]
  y_max = dict_sample[&#39;y_box_max&#39;]
  #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

  #look for the name of the new plot
  template_name = &#39;Debug/DEM_ite/PF_ite_&#39;
  j = 0
  plotpath = Path(template_name+str(j)+&#39;.png&#39;)
  while plotpath.exists():
      j = j + 1
      plotpath = Path(template_name+str(j)+&#39;.png&#39;)
  name = template_name+str(j)+&#39;.png&#39;

  #create the plot
  fig = plt.figure(1,figsize=(16,9.12))
  for grain in dict_sample[&#39;L_g&#39;]:
      if grain.dissolved:
          plt.plot(grain.l_border_x,grain.l_border_y,&#39;k-.&#39;)
      else:
          plt.plot(grain.l_border_x,grain.l_border_y,&#39;k&#39;)
  plt.plot([x_min,x_max,x_max,x_min,x_min],[y_min,y_min,y_max,y_max,y_min],&#39;k&#39;)
  plt.axis(&#34;equal&#34;)
  fig.savefig(name)
  plt.close(1)

#-------------------------------------------------------------------------------

def Debug_Trackers(dict_tracker):
    &#34;&#34;&#34;
    Plot the trakers used during PFDEM simulation

        Input :
            a tracker dictionnary (a dict)
        Output :
            Nothing, but severals .png files are generated (files)
    &#34;&#34;&#34;
    #Trackers
    fig = plt.figure(1,figsize=(16,9.12))
    plt.plot(dict_tracker[&#39;t_L&#39;],dict_tracker[&#39;S_grains_dissolvable_L&#39;])
    plt.title(&#39;Evolution of the dissolvable grains surface&#39;)
    fig.savefig(&#39;Debug/Evolution_Dissolvable_Surface.png&#39;)
    plt.close(1)

    fig = plt.figure(1,figsize=(16,9.12))
    plt.plot(dict_tracker[&#39;S_dissolved_perc_dissolvable_L&#39;][:-1],dict_tracker[&#39;k0_xmin_L&#39;],label=&#39;k0 with xmin&#39;)
    plt.plot(dict_tracker[&#39;S_dissolved_perc_dissolvable_L&#39;][:-1],dict_tracker[&#39;k0_xmax_L&#39;],label=&#39;k0 with xmax&#39;)
    plt.title(&#39;Evolution of the k0&#39;)
    plt.xlabel(&#39;Percentage of dissolvable grains surface dissolved (%)&#39;)
    fig.savefig(&#39;Debug/Evolution_k0_with_percentage_dissolved.png&#39;)
    plt.close(1)

#-------------------------------------------------------------------------------

def Debug_Trackers_DEM(dict_algorithm,dict_sollicitations,dict_tracker):
    &#34;&#34;&#34;
    Plot the trakers used during DEM simulation.

        Input :
            an algorithm dictionnary (a dict)
            a sollicitations dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but .png file is generated (a file)
    &#34;&#34;&#34;
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2,2, figsize=(16,9),num=1)

    ax1.set_title(&#39;Mean kinetic energy (e-12 J)&#39;)
    ax1.plot(dict_tracker[&#39;Ecin&#39;])
    ax1.plot([0, len(dict_tracker[&#39;Ecin&#39;])-1],[dict_algorithm[&#39;Ecin_stop&#39;], dict_algorithm[&#39;Ecin_stop&#39;]],&#39;r&#39;)

    ax2.set_title(&#39;Mean force applied (ÂµN)&#39;)
    ax2.plot(dict_tracker[&#39;Force_applied&#39;])

    ax3.set_title(&#39;k0s (-)&#39;)
    ax3.plot(dict_tracker[&#39;k0_xmin&#39;],label=&#39;xmin&#39;)
    ax3.plot(dict_tracker[&#39;k0_xmax&#39;],label=&#39;xmax&#39;)
    ax3.legend()

    ax4.set_title(&#39;About the upper plate&#39;)
    ax4.plot(dict_tracker[&#39;y_box_max&#39;], color = &#39;blue&#39;)
    ax4.set_ylabel(&#39;Coordinate y (Âµm)&#39;, color = &#39;blue&#39;)
    ax4.tick_params(axis =&#39;y&#39;, labelcolor = &#39;blue&#39;)
    ax4a = ax4.twinx()
    ax4a.plot(range(50,len(dict_tracker[&#39;Force_on_upper_wall&#39;])),dict_tracker[&#39;Force_on_upper_wall&#39;][50:], color = &#39;orange&#39;)
    ax4a.plot([50, len(dict_tracker[&#39;Force_on_upper_wall&#39;])-1],[dict_sollicitations[&#39;Vertical_Confinement_Force&#39;], dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]], color = &#39;red&#39;)
    ax4a.set_ylabel(&#39;Force applied (ÂµN)&#39;, color = &#39;orange&#39;)
    ax4a.tick_params(axis =&#39;y&#39;, labelcolor = &#39;orange&#39;)

    fig.savefig(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/Trackers.png&#39;)
    plt.close(1)

#-------------------------------------------------------------------------------

def Sort_Files(name_template,dict_algorithm):
     &#34;&#34;&#34;
     Sort files generated by MOOSE to different directories.

        Input :
            a template of the simulation files (a string)
            an algorithm dictionnary (a dict)
        Output :
            Nothing, but files are sorted
     &#34;&#34;&#34;
     #master simulation
     os.rename(name_template+&#39;_out.e&#39;,&#39;Output/&#39;+name_template+&#39;_out.e&#39;)
     os.rename(name_template+&#39;.i&#39;,&#39;Input/&#39;+name_template+&#39;.i&#39;)
     if Path(&#39;Output/&#39;+name_template).exists():
         shutil.rmtree(&#39;Output/&#39;+name_template)
     os.mkdir(&#39;Output/&#39;+name_template)
     j = 0
     j_str = index_to_str(j)
     folderpath = Path(name_template+&#39;_other_&#39;+j_str+&#39;.pvtu&#39;)
     while folderpath.exists():
         for i_proc in range(dict_algorithm[&#39;np_proc&#39;]):
            os.rename(name_template+&#39;_other_&#39;+j_str+&#39;_&#39;+str(i_proc)+&#39;.vtu&#39;,&#39;Output/&#39;+name_template+&#39;/&#39;+name_template+&#39;_other_&#39;+j_str+&#39;_&#39;+str(i_proc)+&#39;.vtu&#39;)
         os.rename(name_template+&#39;_other_&#39;+j_str+&#39;.pvtu&#39;,&#39;Output/&#39;+name_template+&#39;/&#39;+name_template+&#39;_other_&#39;+j_str+&#39;.pvtu&#39;)
         j = j + 1
         j_str = index_to_str(j)
         folderpath = Path(name_template+&#39;_other_&#39;+j_str+&#39;.pvtu&#39;)

     return index_to_str(j-1)

#-------------------------------------------------------------------------------

def error_on_ymax_f(dy,overlap_L,k_L,Force_target) :
    &#34;&#34;&#34;
    Compute the function f to control the upper wall. It is the difference between the force applied and the target value.

        Input :
            an increment of the upper wall position (a float)
            a list of overlap for contact between grain and upper wall (a list)
            a list of spring for contact between grain and upper wall (a list)
            a confinement force (a float)
        Output :
            the difference between the force applied and the confinement (a float)
    &#34;&#34;&#34;
    f = Force_target
    for i in range(len(overlap_L)):
        f = f - k_L[i]*(max(overlap_L[i]-dy,0))**(3/2)
    return f

#-------------------------------------------------------------------------------

def error_on_ymax_df(dy,overlap_L,k_L) :
    &#34;&#34;&#34;
    Compute the derivative function df to control the upper wall (error_on_ymax_f()).

        Input :
            an increment of the upper wall position (a float)
            a list of overlap for contact between grain and upper wall (a list)
            a list of spring for contact between grain and upper wall (a list)
        Output :
            the derivative of error_on_ymax_f() (a float)
    &#34;&#34;&#34;
    df = 0
    for i in range(len(overlap_L)):
        df = df + 3/2*k_L[i]*(max(overlap_L[i]-dy,0))**(1/2)
    return df

#-------------------------------------------------------------------------------

def Control_y_max_NR(dict_sample,dict_sollicitations):
    &#34;&#34;&#34;
    Control the upper wall to apply force.

    A Newton-Raphson method is applied to verify the confinement.
        Input :
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
        Output :
            Nothing, but the sample dictionnary is updated, concerning the upper wall position and force applied (two floats)
    &#34;&#34;&#34;
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
    #load data needed
    Force_target = dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

    F = 0
    overlap_L = []
    k_L = []
    for contact in dict_sample[&#39;L_contact_gw&#39;]:
        if contact.nature == &#39;gwy_max&#39;:
            F = F + contact.Fwg_n
            overlap_L.append(contact.overlap)
            k_L.append(contact.k)
            #compute force applied, save contact overlap and spring

    if overlap_L != []:
        i_NR = 0
        dy = 0
        ite_criteria = True
        if -0.01*Force_target&lt;error_on_ymax_f(dy,overlap_L,k_L,Force_target) and error_on_ymax_f(dy,overlap_L,k_L,Force_target)&lt;0.01*Force_target:
            ite_criteria = False
        while ite_criteria :
            i_NR = i_NR + 1
            dy = dy - error_on_ymax_f(dy,overlap_L,k_L,Force_target)/error_on_ymax_df(dy,overlap_L,k_L)
            if i_NR &gt; 100:
                ite_criteria = False
            if -0.01*Force_target&lt;error_on_ymax_f(dy,overlap_L,k_L,Force_target) and error_on_ymax_f(dy,overlap_L,k_L,Force_target)&lt;0.01*Force_target:
                ite_criteria = False
        dict_sample[&#39;y_box_max&#39;] = dict_sample[&#39;y_box_max&#39;] + dy

    else :
        #if there is no contact with the upper wall, the wall is reset
        dict_sample[&#39;y_box_max&#39;] = Reset_y_max(dict_sample[&#39;L_g&#39;],Force_target)

    for contact in dict_sample[&#39;L_contact_gw&#39;]:
        if contact.nature == &#39;gwy_max&#39;:
            #reactualisation
            contact.limit = dict_sample[&#39;y_box_max&#39;]

    #Update dict
    dict_sollicitations[&#39;Force_on_upper_wall&#39;] = F

#-------------------------------------------------------------------------------

def Reset_y_max(L_g,Force):
    &#34;&#34;&#34;
    The upper wall is located as a single contact verify the target value.

        Input :
            the list of temporary grains (a list)
            the confinement force (a float)
        Output :
            the upper wall position (a float)
    &#34;&#34;&#34;
    print(&#39;Reset of the y_max on the upper grain&#39;)
    y_max = None
    id_grain_max = None
    for id_grain in range(len(L_g)):
        grain = L_g[id_grain]
        y_max_grain = max(grain.l_border_y)

        if y_max != None and y_max_grain &gt; y_max:
            y_max = y_max_grain
            id_grain_max = id_grain
        elif y_max == None:
            y_max = y_max_grain
            id_grain_max = id_grain

    k = 5*4/3*L_g[id_grain_max].y/(1-L_g[id_grain_max].nu*L_g[id_grain_max].nu)*math.sqrt(L_g[id_grain_max].r_mean)
    y_max = y_max - (Force/k)**(2/3)

    return y_max

#-------------------------------------------------------------------------------

def Compute_k0(dict_sample,dict_sollicitations):
    &#34;&#34;&#34;
    Compute the k0 = sigma_2 / sigma_1 ratio.

        Input :
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
        Output :
            Nothing, but the sample dictionnary gets updated value concerning the k0
    &#34;&#34;&#34;
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
    #Load data needed
    L_contact_gw = dict_sample[&#39;L_contact_gw&#39;]
    x_min = dict_sample[&#39;x_box_min&#39;]
    x_max = dict_sample[&#39;x_box_max&#39;]
    y_min = dict_sample[&#39;y_box_min&#39;]
    y_max = dict_sample[&#39;y_box_max&#39;]
    F_y_max = dict_sollicitations[&#39;Force_on_upper_wall&#39;]
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

    #compute the forces applied on left and right walls (to compute k0)
    F_x_min = 0
    F_x_max = 0
    for contact in L_contact_gw:
        if contact.nature == &#39;gwx_min&#39;:
            F_x_min = F_x_min + contact.Fwg_n
        elif contact.nature == &#39;gwx_max&#39;:
            F_x_max = F_x_max + contact.Fwg_n

    #compute k0 = (sigma_2/sigma_1)
    sigma_x_min = F_x_min / (y_max-y_min)
    sigma_x_max = F_x_max / (y_max-y_min)
    sigma_y_max = F_y_max / (x_max-x_min)

    if sigma_y_max!= 0:
        k0_xmin = abs(sigma_x_min/sigma_y_max)
        k0_xmax = abs(sigma_x_min/sigma_y_max)
    else :
        k0_xmin = 0
        k0_xmax = 0

    #update element in dicts
    dict_sample[&#39;k0_xmin&#39;] = k0_xmin
    dict_sample[&#39;k0_xmax&#39;] = k0_xmax

#-------------------------------------------------------------------------------

def Write_e_dissolution_txt(dict_sample,dict_sollicitations):
      &#34;&#34;&#34;
      Write an .txt file for MOOSE. This file described an homogenous dissolution field.

        Input :
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
        Output :
            Nothing, but a .txt file is generated (a file)
      &#34;&#34;&#34;
      #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
      #Load data needed
      x_L = dict_sample[&#39;x_L&#39;]
      y_L = dict_sample[&#39;y_L&#39;]
      e_dissolution = dict_sollicitations[&#39;Dissolution_Energy&#39;]
      #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

      file_to_write = open(&#39;Data/e_dissolution.txt&#39;,&#39;w&#39;)
      file_to_write.write(&#39;AXIS X\n&#39;)
      line = &#39;&#39;
      for x in x_L:
          line = line + str(x)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;AXIS Y\n&#39;)
      line = &#39;&#39;
      for y in y_L:
        line = line + str(y)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;DATA\n&#39;)
      for l in range(len(y_L)):
          for c in range(len(x_L)):
              file_to_write.write(str(e_dissolution)+&#39;\n&#39;)

      file_to_write.close()

#-------------------------------------------------------------------------------

def Plot_chain_force(i_PF,i_DEM):
    &#34;&#34;&#34;
    Plot the chain force.

        Input :
            the iteration PFDEM (a int)
            the iteration DEM (a int)
        Output :
            Nothing, but a .png file is generated (a file)
    &#34;&#34;&#34;
    normal_ref = 5*10**6 #can be changed

    file_name = &#39;Debug/DEM_ite/PF_&#39;+str(i_PF)+&#39;/txt/ite_DEM_&#39;+str(i_DEM)+&#39;.txt&#39;
    file = open(file_name,&#39;r&#39;)
    lines = file.readlines()
    file.close()

    L_g = []
    L_contact = []
    L_contact_gw = []
    Read_one_grain = False
    Read_one_contact = False
    Read_one_contact_wall = False
    for line in lines :

        if line == &#39;&lt;grain_c&gt;\n&#39;:
            Read_one_grain = False
            L_g.append(Grain_pp(id,dissolved,center,coordinate_x,coordinate_y))
        elif line == &#39;&lt;contact_c&gt;\n&#39;:
            Read_one_contact = False
            L_contact.append(Contact_pp(L_id_g[0], L_id_g[1], L_g, normal_reaction+normal_damping))
        elif line == &#39;&lt;contact_w_c&gt;\n&#39;:
            Read_one_contact_wall = False
            L_contact_gw.append(Contact_gw_pp(id_g, L_g, type, limit, normal_reaction+normal_damping))

        if Read_one_grain:
            if line[:len(&#39;\tid : &#39;)] == &#39;\tid : &#39;:
                Read_data = False
                for c in range(len(&#39;\tid : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        id = float(line[c_start:c])
                        Read_data = False
            elif line[:len(&#39;\tDissolved : &#39;)] == &#39;\tDissolved : &#39;:
                Read_data = False
                for c in range(len(&#39;\tDissolved : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        if line[c_start:c] == &#39;True&#39;:
                            dissolved = True
                        else :
                            dissolved = False
                        Read_data = False
            elif line[:len(&#39;\tCenter : &#39;)] == &#39;\tCenter : &#39;:
                Read_data = False
                center = []
                for c in range(len(&#39;\tCenter : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39; and line[c]!=&#39;[&#39; and line[c]!=&#39;]&#39; and line[c]!=&#39;,&#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or line[c]==&#39;,&#39; or line[c]==&#39;]&#39;) and Read_data:
                        data = float(line[c_start:c])
                        center.append(data)
                        Read_data = False
            elif line[:len(&#39;\tCoordinate X of the border : &#39;)] == &#39;\tCoordinate X of the border : &#39;:
                Read_data = False
                coordinate_x = []
                for c in range(len(&#39;\tCoordinate X of the border : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39; and line[c]!=&#39;[&#39; and line[c]!=&#39;]&#39; and line[c]!=&#39;,&#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or line[c]==&#39;,&#39; or line[c]==&#39;]&#39;) and Read_data:
                        data = float(line[c_start:c])
                        coordinate_x.append(data)
                        Read_data = False
            elif line[:len(&#39;\tCoordinate Y of the border : &#39;)] == &#39;\tCoordinate Y of the border : &#39;:
                Read_data = False
                coordinate_y = []
                for c in range(len(&#39;\tCoordinate Y of the border : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39; and line[c]!=&#39;[&#39; and line[c]!=&#39;]&#39; and line[c]!=&#39;,&#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or line[c]==&#39;,&#39; or line[c]==&#39;]&#39;) and Read_data:
                        data = float(line[c_start:c])
                        coordinate_y.append(data)
                        Read_data = False

        if Read_one_contact:
            if line[:len(&#39;\tGrains : &#39;)] == &#39;\tGrains : &#39;:
                Read_data = False
                L_id_g = []
                for c in range(len(&#39;\tGrains : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39; and line[c]!=&#39;-&#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or line[c]==&#39;-&#39; or c==len(line)-1) and Read_data:
                        data = float(line[c_start:c])
                        L_id_g.append(data)
                        Read_data = False
            elif line[:len(&#39;\tNormal reaction : &#39;)] == &#39;\tNormal reaction : &#39;:
                Read_data = False
                for c in range(len(&#39;\tNormal reaction : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        normal_reaction = float(line[c_start:c])
                        Read_data = False
            elif line[:len(&#39;\tNormal damping : &#39;)] == &#39;\tNormal damping : &#39;:
                Read_data = False
                for c in range(len(&#39;\tNormal damping : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        normal_damping = float(line[c_start:c])
                        Read_data = False

        if Read_one_contact_wall:
            if line[:len(&#39;\tType : &#39;)] == &#39;\tType : &#39;:
                Read_data = False
                for c in range(len(&#39;\tType : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        type = line[c_start:c]
                        Read_data = False
            elif line[:len(&#39;\tGrain : &#39;)] == &#39;\tGrain : &#39;:
                Read_data = False
                for c in range(len(&#39;\tGrain : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        id_g = float(line[c_start:c])
                        Read_data = False
            elif line[:len(&#39;\tLimit : &#39;)] == &#39;\tLimit : &#39;:
                Read_data = False
                for c in range(len(&#39;\tLimit : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        limit = float(line[c_start:c])
                        Read_data = False
                if type == &#39;gwx_min&#39;:
                    x_min = limit
                elif type == &#39;gwx_max&#39;:
                    x_max = limit
                elif type == &#39;gwy_min&#39;:
                    y_min = limit
                elif type == &#39;gwy_max&#39;:
                    y_max = limit
            elif line[:len(&#39;\tNormal reaction : &#39;)] == &#39;\tNormal reaction : &#39;:
                Read_data = False
                for c in range(len(&#39;\tNormal reaction : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        normal_reaction = float(line[c_start:c])
                        Read_data = False
            elif line[:len(&#39;\tNormal damping : &#39;)] == &#39;\tNormal damping : &#39;:
                Read_data = False
                for c in range(len(&#39;\tNormal damping : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        normal_damping = float(line[c_start:c])
                        Read_data = False

        if line == &#39;&lt;grain_o&gt;\n&#39;:
            Read_one_grain = True
        elif line == &#39;&lt;contact_o&gt;\n&#39;:
            Read_one_contact = True
        elif line == &#39;&lt;contact_w_o&gt;\n&#39;:
            Read_one_contact_wall = True

    plt.figure(1,figsize=(16,9))
    plt.plot([x_min, x_max, x_max, x_min, x_min],[y_min, y_min, y_max, y_max, y_min],&#39;k&#39;)
    for grain in L_g:
        if grain.dissolved:
            plt.plot(grain.coordinate_x,grain.coordinate_y,color= &#39;k&#39;,linestyle=&#39;-.&#39;)
        else :
            plt.plot(grain.coordinate_x,grain.coordinate_y,color= &#39;k&#39;)
    for contact in L_contact+L_contact_gw:
        L_x, L_y, ratio_normal = contact.plot(normal_ref)
        plt.plot(L_x,L_y,linewidth = ratio_normal,color = &#39;k&#39;)
    plt.axis(&#34;equal&#34;)
    plt.savefig(&#39;Debug/DEM_ite/Chain_force_&#39;+str(i_PF)+&#39;.png&#39;)
    plt.close(1)

#-------------------------------------------------------------------------------

def make_mp4():
    &#34;&#34;&#34;
    The goal of this function is to create a movie with all configuration pictures.

    From https://www.blog.pythonlibrary.org/2021/06/23/creating-an-animated-gif-with-python/

        Input :
            Nothing
        Output :
            Nothing, but a .mp4 file is generated (a file)
    &#34;&#34;&#34;
    #look for the largest iteration
    template_name = &#39;Debug/DEM_ite/PF_ite_&#39;
    i_f = 0
    plotpath = Path(template_name+str(i_f)+&#39;.png&#39;)
    while plotpath.exists():
        i_f = i_f + 1
        plotpath = Path(template_name+str(i_f)+&#39;.png&#39;)

    fileList = []
    for i in range(0,i_f):
        fileList.append(template_name+str(i)+&#39;.png&#39;)

    duration_movie  = 10 #sec
    writer = imageio.get_writer(&#39;Debug/PF_ite.mp4&#39;, fps=int(i_f/duration_movie))
    for im in fileList:
        writer.append_data(imageio.imread(im))
    writer.close()

#-------------------------------------------------------------------------------

def save_DEM_tempo(dict_algorithm,dict_sample,dict_sollicitations,dict_tracker):
    &#34;&#34;&#34;
    Save trackers and configuration during DEM interations.

        Input :
            an algorithm dictionnary (a dict)
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    outfile = open(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/save_tempo&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;E_cin_stop&#39;] = dict_algorithm[&#39;Ecin_stop&#39;]
    dict_save[&#39;n_window_stop&#39;] = dict_algorithm[&#39;n_window_stop&#39;]
    dict_save[&#39;dy_box_max_stop&#39;] = dict_algorithm[&#39;dy_box_max_stop&#39;]
    dict_save[&#39;dk0_stop&#39;] = dict_algorithm[&#39;dk0_stop&#39;]
    dict_save[&#39;L_g&#39;] = dict_sample[&#39;L_g&#39;]
    dict_save[&#39;L_contact&#39;] = dict_sample[&#39;L_contact&#39;]
    dict_save[&#39;L_ij_contact&#39;] = dict_sample[&#39;L_ij_contact&#39;]
    dict_save[&#39;L_contact_gw&#39;] = dict_sample[&#39;L_contact_gw&#39;]
    dict_save[&#39;L_ij_contact_gw&#39;] = dict_sample[&#39;L_ij_contact_gw&#39;]
    dict_save[&#39;F_on_ymax&#39;] = dict_sollicitations[&#39;Force_on_upper_wall&#39;]
    dict_save[&#39;E_cin&#39;] = dict_tracker[&#39;Ecin&#39;]
    dict_save[&#39;Force&#39;] = dict_tracker[&#39;Force_applied&#39;]
    dict_save[&#39;k0_xmin_tracker&#39;] = dict_tracker[&#39;k0_xmin&#39;]
    dict_save[&#39;k0_xmax_tracker&#39;] = dict_tracker[&#39;k0_xmax&#39;]
    dict_save[&#39;y_box_max&#39;] = dict_tracker[&#39;y_box_max&#39;][:-1]
    pickle.dump(dict_save,outfile)
    outfile.close()

#-------------------------------------------------------------------------------

def save_DEM_final(dict_algorithm,dict_sample,dict_sollicitations,dict_tracker):
    &#34;&#34;&#34;
    Save trackers and configuration at the end of DEM iteration.

        Input :
            an algorithm dictionnary (a dict)
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    os.remove(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/save_tempo&#39;)
    outfile = open(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/save&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;E_cin_stop&#39;] = dict_algorithm[&#39;Ecin_stop&#39;]
    dict_save[&#39;n_window_stop&#39;] = dict_algorithm[&#39;n_window_stop&#39;]
    dict_save[&#39;dy_box_max_stop&#39;] = dict_algorithm[&#39;dy_box_max_stop&#39;]
    dict_save[&#39;dk0_stop&#39;] = dict_algorithm[&#39;dk0_stop&#39;]
    dict_save[&#39;L_g&#39;] = dict_sample[&#39;L_g&#39;]
    dict_save[&#39;L_contact&#39;] = dict_sample[&#39;L_contact&#39;]
    dict_save[&#39;L_ij_contact&#39;] = dict_sample[&#39;L_ij_contact&#39;]
    dict_save[&#39;L_contact_gw&#39;] = dict_sample[&#39;L_contact_gw&#39;]
    dict_save[&#39;L_ij_contact_gw&#39;] = dict_sample[&#39;L_ij_contact_gw&#39;]
    dict_save[&#39;F_on_ymax&#39;] = dict_sollicitations[&#39;Force_on_upper_wall&#39;]
    dict_save[&#39;E_cin&#39;] = dict_tracker[&#39;Ecin&#39;]
    dict_save[&#39;Force&#39;] = dict_tracker[&#39;Force_applied&#39;]
    dict_save[&#39;k0_xmin_tracker&#39;] = dict_tracker[&#39;k0_xmin&#39;]
    dict_save[&#39;k0_xmax_tracker&#39;] = dict_tracker[&#39;k0_xmax&#39;]
    dict_save[&#39;y_box_max&#39;] = dict_tracker[&#39;y_box_max&#39;][:-1]
    pickle.dump(dict_save,outfile)
    outfile.close()

#-------------------------------------------------------------------------------

def save_dicts(dict_algorithm, dict_geometry, dict_material, dict_sample, dict_sollicitations, dict_tracker):
    &#34;&#34;&#34;
    Save dictionnaries at the end of PFDEM iteration.

        Input :
            an algorithm dictionnary (a dict)
            a geometry dictionnary (a dict)
            a material dictionnary (a dict)
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    outfile = open(dict_algorithm[&#39;name_folder&#39;]+&#39;_save_dicts&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;algorithm&#39;] = dict_algorithm
    dict_save[&#39;geometry&#39;] = dict_geometry
    dict_save[&#39;material&#39;] = dict_material
    dict_save[&#39;sample&#39;] = dict_sample
    dict_save[&#39;sollicitations&#39;] = dict_sollicitations
    dict_save[&#39;tracker&#39;] = dict_tracker
    pickle.dump(dict_save,outfile)
    outfile.close()

#-------------------------------------------------------------------------------

def save_tempo(dict_algorithm,dict_tracker):
    &#34;&#34;&#34;
    Save trackers and configuration during  PFDEM iteration.

        Input :
            an algorithm dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    outfile = open(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_save_tempo&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;k0_xmin_L&#39;] = dict_tracker[&#39;k0_xmin_L&#39;]
    dict_save[&#39;k0_xmax_L&#39;] = dict_tracker[&#39;k0_xmax_L&#39;]
    dict_save[&#39;S_dissolved_L&#39;] = dict_tracker[&#39;S_dissolved_L&#39;]
    dict_save[&#39;S_dissolved_perc_L&#39;] = dict_tracker[&#39;S_dissolved_perc_L&#39;]
    dict_save[&#39;S_grains_L&#39;] = dict_tracker[&#39;S_grains_L&#39;]
    pickle.dump(dict_save,outfile)
    outfile.close()

#-------------------------------------------------------------------------------

def save_final(dict_algorithm,dict_tracker):
    &#34;&#34;&#34;
    Save trackers and configuration at the end of simulation.

        Input :
            an algorithm dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    os.remove(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_save_tempo&#39;)
    outfile = open(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_save&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;k0_xmin_L&#39;] = dict_tracker[&#39;k0_xmin_L&#39;]
    dict_save[&#39;k0_xmax_L&#39;] = dict_tracker[&#39;k0_xmax_L&#39;]
    dict_save[&#39;S_dissolved_L&#39;] = dict_tracker[&#39;S_dissolved_L&#39;]
    dict_save[&#39;S_dissolved_perc_L&#39;] = dict_tracker[&#39;S_dissolved_perc_L&#39;]
    dict_save[&#39;S_grains_L&#39;] = dict_tracker[&#39;S_grains_L&#39;]
    pickle.dump(dict_save,outfile)
    outfile.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Owntools.Compute_k0"><code class="name flex">
<span>def <span class="ident">Compute_k0</span></span>(<span>dict_sample, dict_sollicitations)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the k0 = sigma_2 / sigma_1 ratio.</p>
<pre><code>Input :
    a sample dictionnary (a dict)
    a sollicitations dictionnary (a dict)
Output :
    Nothing, but the sample dictionnary gets updated value concerning the k0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Compute_k0(dict_sample,dict_sollicitations):
    &#34;&#34;&#34;
    Compute the k0 = sigma_2 / sigma_1 ratio.

        Input :
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
        Output :
            Nothing, but the sample dictionnary gets updated value concerning the k0
    &#34;&#34;&#34;
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
    #Load data needed
    L_contact_gw = dict_sample[&#39;L_contact_gw&#39;]
    x_min = dict_sample[&#39;x_box_min&#39;]
    x_max = dict_sample[&#39;x_box_max&#39;]
    y_min = dict_sample[&#39;y_box_min&#39;]
    y_max = dict_sample[&#39;y_box_max&#39;]
    F_y_max = dict_sollicitations[&#39;Force_on_upper_wall&#39;]
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

    #compute the forces applied on left and right walls (to compute k0)
    F_x_min = 0
    F_x_max = 0
    for contact in L_contact_gw:
        if contact.nature == &#39;gwx_min&#39;:
            F_x_min = F_x_min + contact.Fwg_n
        elif contact.nature == &#39;gwx_max&#39;:
            F_x_max = F_x_max + contact.Fwg_n

    #compute k0 = (sigma_2/sigma_1)
    sigma_x_min = F_x_min / (y_max-y_min)
    sigma_x_max = F_x_max / (y_max-y_min)
    sigma_y_max = F_y_max / (x_max-x_min)

    if sigma_y_max!= 0:
        k0_xmin = abs(sigma_x_min/sigma_y_max)
        k0_xmax = abs(sigma_x_min/sigma_y_max)
    else :
        k0_xmin = 0
        k0_xmax = 0

    #update element in dicts
    dict_sample[&#39;k0_xmin&#39;] = k0_xmin
    dict_sample[&#39;k0_xmax&#39;] = k0_xmax</code></pre>
</details>
</dd>
<dt id="Owntools.Control_y_max_NR"><code class="name flex">
<span>def <span class="ident">Control_y_max_NR</span></span>(<span>dict_sample, dict_sollicitations)</span>
</code></dt>
<dd>
<div class="desc"><p>Control the upper wall to apply force.</p>
<p>A Newton-Raphson method is applied to verify the confinement.
Input :
a sample dictionnary (a dict)
a sollicitations dictionnary (a dict)
Output :
Nothing, but the sample dictionnary is updated, concerning the upper wall position and force applied (two floats)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Control_y_max_NR(dict_sample,dict_sollicitations):
    &#34;&#34;&#34;
    Control the upper wall to apply force.

    A Newton-Raphson method is applied to verify the confinement.
        Input :
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
        Output :
            Nothing, but the sample dictionnary is updated, concerning the upper wall position and force applied (two floats)
    &#34;&#34;&#34;
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
    #load data needed
    Force_target = dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

    F = 0
    overlap_L = []
    k_L = []
    for contact in dict_sample[&#39;L_contact_gw&#39;]:
        if contact.nature == &#39;gwy_max&#39;:
            F = F + contact.Fwg_n
            overlap_L.append(contact.overlap)
            k_L.append(contact.k)
            #compute force applied, save contact overlap and spring

    if overlap_L != []:
        i_NR = 0
        dy = 0
        ite_criteria = True
        if -0.01*Force_target&lt;error_on_ymax_f(dy,overlap_L,k_L,Force_target) and error_on_ymax_f(dy,overlap_L,k_L,Force_target)&lt;0.01*Force_target:
            ite_criteria = False
        while ite_criteria :
            i_NR = i_NR + 1
            dy = dy - error_on_ymax_f(dy,overlap_L,k_L,Force_target)/error_on_ymax_df(dy,overlap_L,k_L)
            if i_NR &gt; 100:
                ite_criteria = False
            if -0.01*Force_target&lt;error_on_ymax_f(dy,overlap_L,k_L,Force_target) and error_on_ymax_f(dy,overlap_L,k_L,Force_target)&lt;0.01*Force_target:
                ite_criteria = False
        dict_sample[&#39;y_box_max&#39;] = dict_sample[&#39;y_box_max&#39;] + dy

    else :
        #if there is no contact with the upper wall, the wall is reset
        dict_sample[&#39;y_box_max&#39;] = Reset_y_max(dict_sample[&#39;L_g&#39;],Force_target)

    for contact in dict_sample[&#39;L_contact_gw&#39;]:
        if contact.nature == &#39;gwy_max&#39;:
            #reactualisation
            contact.limit = dict_sample[&#39;y_box_max&#39;]

    #Update dict
    dict_sollicitations[&#39;Force_on_upper_wall&#39;] = F</code></pre>
</details>
</dd>
<dt id="Owntools.Debug_DEM_f"><code class="name flex">
<span>def <span class="ident">Debug_DEM_f</span></span>(<span>dict_algorithm, dict_sample)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the configuration of the grains during a DEM step.</p>
<pre><code>Input:
    an algorithm dictionnary (a dict)
    a sample dictionnary (a dict)
Output :
    Nothing, but a .png file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Debug_DEM_f(dict_algorithm, dict_sample):
    &#34;&#34;&#34;
    Plot the configuration of the grains during a DEM step.

        Input:
            an algorithm dictionnary (a dict)
            a sample dictionnary (a dict)
        Output :
            Nothing, but a .png file is generated (a file)
    &#34;&#34;&#34;
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    #load data needed
    x_min = dict_sample[&#39;x_box_min&#39;]
    x_max = dict_sample[&#39;x_box_max&#39;]
    y_min = dict_sample[&#39;y_box_min&#39;]
    y_max = dict_sample[&#39;y_box_max&#39;]
    #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

    fig = plt.figure(1,figsize=(16,9.12))
    for grain in dict_sample[&#39;L_g&#39;]:
        plt.plot(grain.l_border_x,grain.l_border_y,&#39;k&#39;)
    for contact in dict_sample[&#39;L_contact&#39;] :
        alpha = (contact.g1.r_mean*0.1 + contact.g2.r_mean*0.1)/2
        M = (contact.g1.center + contact.g2.center)/2
        plt.plot([M[0], M[0]+contact.pc_normal[0]*alpha], [M[1], M[1]+contact.pc_normal[1]*alpha],&#39;k&#39;)
        plt.plot([M[0], M[0]+contact.pc_tangential[0]*alpha], [M[1], M[1]+contact.pc_tangential[1]*alpha],&#39;k&#39;)
    for contact in dict_sample[&#39;L_contact_gw&#39;] :
        alpha = contact.g.r_mean*0.1
        if contact.nature == &#39;gwy_min&#39; or contact.nature == &#39;gwy_max&#39;:
            M = np.array([contact.g.center[0],contact.limit])
        elif contact.nature == &#39;gwx_min&#39; or contact.nature == &#39;gwx_max&#39;:
            M = np.array([contact.limit,contact.g.center[1]])
        plt.plot([M[0], M[0]+contact.nwg[0]*alpha], [M[1], M[1]+contact.nwg[1]*alpha],&#39;k&#39;)
        plt.plot([M[0], M[0]+contact.twg[0]*alpha], [M[1], M[1]+contact.twg[1]*alpha],&#39;k&#39;)
    plt.plot([x_min,x_max,x_max,x_min,x_min],[y_min,y_min,y_max,y_max,y_min],&#39;k&#39;)
    plt.axis(&#34;equal&#34;)
    fig.savefig(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/png/Config_&#39;+str(dict_algorithm[&#39;i_DEM&#39;])+&#39;.png&#39;)
    plt.close(1)</code></pre>
</details>
</dd>
<dt id="Owntools.Debug_Trackers"><code class="name flex">
<span>def <span class="ident">Debug_Trackers</span></span>(<span>dict_tracker)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the trakers used during PFDEM simulation</p>
<pre><code>Input :
    a tracker dictionnary (a dict)
Output :
    Nothing, but severals .png files are generated (files)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Debug_Trackers(dict_tracker):
    &#34;&#34;&#34;
    Plot the trakers used during PFDEM simulation

        Input :
            a tracker dictionnary (a dict)
        Output :
            Nothing, but severals .png files are generated (files)
    &#34;&#34;&#34;
    #Trackers
    fig = plt.figure(1,figsize=(16,9.12))
    plt.plot(dict_tracker[&#39;t_L&#39;],dict_tracker[&#39;S_grains_dissolvable_L&#39;])
    plt.title(&#39;Evolution of the dissolvable grains surface&#39;)
    fig.savefig(&#39;Debug/Evolution_Dissolvable_Surface.png&#39;)
    plt.close(1)

    fig = plt.figure(1,figsize=(16,9.12))
    plt.plot(dict_tracker[&#39;S_dissolved_perc_dissolvable_L&#39;][:-1],dict_tracker[&#39;k0_xmin_L&#39;],label=&#39;k0 with xmin&#39;)
    plt.plot(dict_tracker[&#39;S_dissolved_perc_dissolvable_L&#39;][:-1],dict_tracker[&#39;k0_xmax_L&#39;],label=&#39;k0 with xmax&#39;)
    plt.title(&#39;Evolution of the k0&#39;)
    plt.xlabel(&#39;Percentage of dissolvable grains surface dissolved (%)&#39;)
    fig.savefig(&#39;Debug/Evolution_k0_with_percentage_dissolved.png&#39;)
    plt.close(1)</code></pre>
</details>
</dd>
<dt id="Owntools.Debug_Trackers_DEM"><code class="name flex">
<span>def <span class="ident">Debug_Trackers_DEM</span></span>(<span>dict_algorithm, dict_sollicitations, dict_tracker)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the trakers used during DEM simulation.</p>
<pre><code>Input :
    an algorithm dictionnary (a dict)
    a sollicitations dictionnary (a dict)
    a tracker dictionnary (a dict)
Output :
    Nothing, but .png file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Debug_Trackers_DEM(dict_algorithm,dict_sollicitations,dict_tracker):
    &#34;&#34;&#34;
    Plot the trakers used during DEM simulation.

        Input :
            an algorithm dictionnary (a dict)
            a sollicitations dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but .png file is generated (a file)
    &#34;&#34;&#34;
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2,2, figsize=(16,9),num=1)

    ax1.set_title(&#39;Mean kinetic energy (e-12 J)&#39;)
    ax1.plot(dict_tracker[&#39;Ecin&#39;])
    ax1.plot([0, len(dict_tracker[&#39;Ecin&#39;])-1],[dict_algorithm[&#39;Ecin_stop&#39;], dict_algorithm[&#39;Ecin_stop&#39;]],&#39;r&#39;)

    ax2.set_title(&#39;Mean force applied (ÂµN)&#39;)
    ax2.plot(dict_tracker[&#39;Force_applied&#39;])

    ax3.set_title(&#39;k0s (-)&#39;)
    ax3.plot(dict_tracker[&#39;k0_xmin&#39;],label=&#39;xmin&#39;)
    ax3.plot(dict_tracker[&#39;k0_xmax&#39;],label=&#39;xmax&#39;)
    ax3.legend()

    ax4.set_title(&#39;About the upper plate&#39;)
    ax4.plot(dict_tracker[&#39;y_box_max&#39;], color = &#39;blue&#39;)
    ax4.set_ylabel(&#39;Coordinate y (Âµm)&#39;, color = &#39;blue&#39;)
    ax4.tick_params(axis =&#39;y&#39;, labelcolor = &#39;blue&#39;)
    ax4a = ax4.twinx()
    ax4a.plot(range(50,len(dict_tracker[&#39;Force_on_upper_wall&#39;])),dict_tracker[&#39;Force_on_upper_wall&#39;][50:], color = &#39;orange&#39;)
    ax4a.plot([50, len(dict_tracker[&#39;Force_on_upper_wall&#39;])-1],[dict_sollicitations[&#39;Vertical_Confinement_Force&#39;], dict_sollicitations[&#39;Vertical_Confinement_Force&#39;]], color = &#39;red&#39;)
    ax4a.set_ylabel(&#39;Force applied (ÂµN)&#39;, color = &#39;orange&#39;)
    ax4a.tick_params(axis =&#39;y&#39;, labelcolor = &#39;orange&#39;)

    fig.savefig(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/Trackers.png&#39;)
    plt.close(1)</code></pre>
</details>
</dd>
<dt id="Owntools.Debug_configuration"><code class="name flex">
<span>def <span class="ident">Debug_configuration</span></span>(<span>dict_algorithm, dict_sample)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the configuration of the grains before / after the DEM step.</p>
<pre><code>  Input:
      an algorithm dictionnary (a dict)
      a sample dictionnary (a dict)
  Output :
      Nothing, but a .png file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Debug_configuration(dict_algorithm,dict_sample):
  &#34;&#34;&#34;
  Plot the configuration of the grains before / after the DEM step.

        Input:
            an algorithm dictionnary (a dict)
            a sample dictionnary (a dict)
        Output :
            Nothing, but a .png file is generated (a file)
  &#34;&#34;&#34;
  #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
  #load data needed
  x_min = dict_sample[&#39;x_box_min&#39;]
  x_max = dict_sample[&#39;x_box_max&#39;]
  y_min = dict_sample[&#39;y_box_min&#39;]
  y_max = dict_sample[&#39;y_box_max&#39;]
  #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

  #look for the name of the new plot
  template_name = &#39;Debug/DEM_ite/PF_ite_&#39;
  j = 0
  plotpath = Path(template_name+str(j)+&#39;.png&#39;)
  while plotpath.exists():
      j = j + 1
      plotpath = Path(template_name+str(j)+&#39;.png&#39;)
  name = template_name+str(j)+&#39;.png&#39;

  #create the plot
  fig = plt.figure(1,figsize=(16,9.12))
  for grain in dict_sample[&#39;L_g&#39;]:
      if grain.dissolved:
          plt.plot(grain.l_border_x,grain.l_border_y,&#39;k-.&#39;)
      else:
          plt.plot(grain.l_border_x,grain.l_border_y,&#39;k&#39;)
  plt.plot([x_min,x_max,x_max,x_min,x_min],[y_min,y_min,y_max,y_max,y_min],&#39;k&#39;)
  plt.axis(&#34;equal&#34;)
  fig.savefig(name)
  plt.close(1)</code></pre>
</details>
</dd>
<dt id="Owntools.Plot_chain_force"><code class="name flex">
<span>def <span class="ident">Plot_chain_force</span></span>(<span>i_PF, i_DEM)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the chain force.</p>
<pre><code>Input :
    the iteration PFDEM (a int)
    the iteration DEM (a int)
Output :
    Nothing, but a .png file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Plot_chain_force(i_PF,i_DEM):
    &#34;&#34;&#34;
    Plot the chain force.

        Input :
            the iteration PFDEM (a int)
            the iteration DEM (a int)
        Output :
            Nothing, but a .png file is generated (a file)
    &#34;&#34;&#34;
    normal_ref = 5*10**6 #can be changed

    file_name = &#39;Debug/DEM_ite/PF_&#39;+str(i_PF)+&#39;/txt/ite_DEM_&#39;+str(i_DEM)+&#39;.txt&#39;
    file = open(file_name,&#39;r&#39;)
    lines = file.readlines()
    file.close()

    L_g = []
    L_contact = []
    L_contact_gw = []
    Read_one_grain = False
    Read_one_contact = False
    Read_one_contact_wall = False
    for line in lines :

        if line == &#39;&lt;grain_c&gt;\n&#39;:
            Read_one_grain = False
            L_g.append(Grain_pp(id,dissolved,center,coordinate_x,coordinate_y))
        elif line == &#39;&lt;contact_c&gt;\n&#39;:
            Read_one_contact = False
            L_contact.append(Contact_pp(L_id_g[0], L_id_g[1], L_g, normal_reaction+normal_damping))
        elif line == &#39;&lt;contact_w_c&gt;\n&#39;:
            Read_one_contact_wall = False
            L_contact_gw.append(Contact_gw_pp(id_g, L_g, type, limit, normal_reaction+normal_damping))

        if Read_one_grain:
            if line[:len(&#39;\tid : &#39;)] == &#39;\tid : &#39;:
                Read_data = False
                for c in range(len(&#39;\tid : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        id = float(line[c_start:c])
                        Read_data = False
            elif line[:len(&#39;\tDissolved : &#39;)] == &#39;\tDissolved : &#39;:
                Read_data = False
                for c in range(len(&#39;\tDissolved : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        if line[c_start:c] == &#39;True&#39;:
                            dissolved = True
                        else :
                            dissolved = False
                        Read_data = False
            elif line[:len(&#39;\tCenter : &#39;)] == &#39;\tCenter : &#39;:
                Read_data = False
                center = []
                for c in range(len(&#39;\tCenter : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39; and line[c]!=&#39;[&#39; and line[c]!=&#39;]&#39; and line[c]!=&#39;,&#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or line[c]==&#39;,&#39; or line[c]==&#39;]&#39;) and Read_data:
                        data = float(line[c_start:c])
                        center.append(data)
                        Read_data = False
            elif line[:len(&#39;\tCoordinate X of the border : &#39;)] == &#39;\tCoordinate X of the border : &#39;:
                Read_data = False
                coordinate_x = []
                for c in range(len(&#39;\tCoordinate X of the border : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39; and line[c]!=&#39;[&#39; and line[c]!=&#39;]&#39; and line[c]!=&#39;,&#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or line[c]==&#39;,&#39; or line[c]==&#39;]&#39;) and Read_data:
                        data = float(line[c_start:c])
                        coordinate_x.append(data)
                        Read_data = False
            elif line[:len(&#39;\tCoordinate Y of the border : &#39;)] == &#39;\tCoordinate Y of the border : &#39;:
                Read_data = False
                coordinate_y = []
                for c in range(len(&#39;\tCoordinate Y of the border : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39; and line[c]!=&#39;[&#39; and line[c]!=&#39;]&#39; and line[c]!=&#39;,&#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or line[c]==&#39;,&#39; or line[c]==&#39;]&#39;) and Read_data:
                        data = float(line[c_start:c])
                        coordinate_y.append(data)
                        Read_data = False

        if Read_one_contact:
            if line[:len(&#39;\tGrains : &#39;)] == &#39;\tGrains : &#39;:
                Read_data = False
                L_id_g = []
                for c in range(len(&#39;\tGrains : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39; and line[c]!=&#39;-&#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or line[c]==&#39;-&#39; or c==len(line)-1) and Read_data:
                        data = float(line[c_start:c])
                        L_id_g.append(data)
                        Read_data = False
            elif line[:len(&#39;\tNormal reaction : &#39;)] == &#39;\tNormal reaction : &#39;:
                Read_data = False
                for c in range(len(&#39;\tNormal reaction : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        normal_reaction = float(line[c_start:c])
                        Read_data = False
            elif line[:len(&#39;\tNormal damping : &#39;)] == &#39;\tNormal damping : &#39;:
                Read_data = False
                for c in range(len(&#39;\tNormal damping : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        normal_damping = float(line[c_start:c])
                        Read_data = False

        if Read_one_contact_wall:
            if line[:len(&#39;\tType : &#39;)] == &#39;\tType : &#39;:
                Read_data = False
                for c in range(len(&#39;\tType : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        type = line[c_start:c]
                        Read_data = False
            elif line[:len(&#39;\tGrain : &#39;)] == &#39;\tGrain : &#39;:
                Read_data = False
                for c in range(len(&#39;\tGrain : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        id_g = float(line[c_start:c])
                        Read_data = False
            elif line[:len(&#39;\tLimit : &#39;)] == &#39;\tLimit : &#39;:
                Read_data = False
                for c in range(len(&#39;\tLimit : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        limit = float(line[c_start:c])
                        Read_data = False
                if type == &#39;gwx_min&#39;:
                    x_min = limit
                elif type == &#39;gwx_max&#39;:
                    x_max = limit
                elif type == &#39;gwy_min&#39;:
                    y_min = limit
                elif type == &#39;gwy_max&#39;:
                    y_max = limit
            elif line[:len(&#39;\tNormal reaction : &#39;)] == &#39;\tNormal reaction : &#39;:
                Read_data = False
                for c in range(len(&#39;\tNormal reaction : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        normal_reaction = float(line[c_start:c])
                        Read_data = False
            elif line[:len(&#39;\tNormal damping : &#39;)] == &#39;\tNormal damping : &#39;:
                Read_data = False
                for c in range(len(&#39;\tNormal damping : &#39;)-1,len(line)):
                    if (line[c]!=&#39; &#39;) and not Read_data:
                        c_start = c
                        Read_data = True
                    elif (line[c]==&#39; &#39; or c==len(line)-1) and Read_data:
                        normal_damping = float(line[c_start:c])
                        Read_data = False

        if line == &#39;&lt;grain_o&gt;\n&#39;:
            Read_one_grain = True
        elif line == &#39;&lt;contact_o&gt;\n&#39;:
            Read_one_contact = True
        elif line == &#39;&lt;contact_w_o&gt;\n&#39;:
            Read_one_contact_wall = True

    plt.figure(1,figsize=(16,9))
    plt.plot([x_min, x_max, x_max, x_min, x_min],[y_min, y_min, y_max, y_max, y_min],&#39;k&#39;)
    for grain in L_g:
        if grain.dissolved:
            plt.plot(grain.coordinate_x,grain.coordinate_y,color= &#39;k&#39;,linestyle=&#39;-.&#39;)
        else :
            plt.plot(grain.coordinate_x,grain.coordinate_y,color= &#39;k&#39;)
    for contact in L_contact+L_contact_gw:
        L_x, L_y, ratio_normal = contact.plot(normal_ref)
        plt.plot(L_x,L_y,linewidth = ratio_normal,color = &#39;k&#39;)
    plt.axis(&#34;equal&#34;)
    plt.savefig(&#39;Debug/DEM_ite/Chain_force_&#39;+str(i_PF)+&#39;.png&#39;)
    plt.close(1)</code></pre>
</details>
</dd>
<dt id="Owntools.Reset_y_max"><code class="name flex">
<span>def <span class="ident">Reset_y_max</span></span>(<span>L_g, Force)</span>
</code></dt>
<dd>
<div class="desc"><p>The upper wall is located as a single contact verify the target value.</p>
<pre><code>Input :
    the list of temporary grains (a list)
    the confinement force (a float)
Output :
    the upper wall position (a float)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Reset_y_max(L_g,Force):
    &#34;&#34;&#34;
    The upper wall is located as a single contact verify the target value.

        Input :
            the list of temporary grains (a list)
            the confinement force (a float)
        Output :
            the upper wall position (a float)
    &#34;&#34;&#34;
    print(&#39;Reset of the y_max on the upper grain&#39;)
    y_max = None
    id_grain_max = None
    for id_grain in range(len(L_g)):
        grain = L_g[id_grain]
        y_max_grain = max(grain.l_border_y)

        if y_max != None and y_max_grain &gt; y_max:
            y_max = y_max_grain
            id_grain_max = id_grain
        elif y_max == None:
            y_max = y_max_grain
            id_grain_max = id_grain

    k = 5*4/3*L_g[id_grain_max].y/(1-L_g[id_grain_max].nu*L_g[id_grain_max].nu)*math.sqrt(L_g[id_grain_max].r_mean)
    y_max = y_max - (Force/k)**(2/3)

    return y_max</code></pre>
</details>
</dd>
<dt id="Owntools.Sort_Files"><code class="name flex">
<span>def <span class="ident">Sort_Files</span></span>(<span>name_template, dict_algorithm)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort files generated by MOOSE to different directories.</p>
<p>Input :
a template of the simulation files (a string)
an algorithm dictionnary (a dict)
Output :
Nothing, but files are sorted</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Sort_Files(name_template,dict_algorithm):
     &#34;&#34;&#34;
     Sort files generated by MOOSE to different directories.

        Input :
            a template of the simulation files (a string)
            an algorithm dictionnary (a dict)
        Output :
            Nothing, but files are sorted
     &#34;&#34;&#34;
     #master simulation
     os.rename(name_template+&#39;_out.e&#39;,&#39;Output/&#39;+name_template+&#39;_out.e&#39;)
     os.rename(name_template+&#39;.i&#39;,&#39;Input/&#39;+name_template+&#39;.i&#39;)
     if Path(&#39;Output/&#39;+name_template).exists():
         shutil.rmtree(&#39;Output/&#39;+name_template)
     os.mkdir(&#39;Output/&#39;+name_template)
     j = 0
     j_str = index_to_str(j)
     folderpath = Path(name_template+&#39;_other_&#39;+j_str+&#39;.pvtu&#39;)
     while folderpath.exists():
         for i_proc in range(dict_algorithm[&#39;np_proc&#39;]):
            os.rename(name_template+&#39;_other_&#39;+j_str+&#39;_&#39;+str(i_proc)+&#39;.vtu&#39;,&#39;Output/&#39;+name_template+&#39;/&#39;+name_template+&#39;_other_&#39;+j_str+&#39;_&#39;+str(i_proc)+&#39;.vtu&#39;)
         os.rename(name_template+&#39;_other_&#39;+j_str+&#39;.pvtu&#39;,&#39;Output/&#39;+name_template+&#39;/&#39;+name_template+&#39;_other_&#39;+j_str+&#39;.pvtu&#39;)
         j = j + 1
         j_str = index_to_str(j)
         folderpath = Path(name_template+&#39;_other_&#39;+j_str+&#39;.pvtu&#39;)

     return index_to_str(j-1)</code></pre>
</details>
</dd>
<dt id="Owntools.Stop_Debug"><code class="name flex">
<span>def <span class="ident">Stop_Debug</span></span>(<span>simulation_report)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop simulation for debugging.</p>
<p>Input :
the simulation report (a report)
Output :
Nothing, but simulations stops</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Stop_Debug(simulation_report):
      &#34;&#34;&#34;
      Stop simulation for debugging.

        Input :
            the simulation report (a report)
        Output :
            Nothing, but simulations stops
      &#34;&#34;&#34;
      simulation_report.write(&#39;Stop because after it is not corrected !\n&#39;)
      simulation_report.end(datetime.now())
      raise ValueError(&#39;Stop because after it is not corrected !&#39;)</code></pre>
</details>
</dd>
<dt id="Owntools.Write_e_dissolution_txt"><code class="name flex">
<span>def <span class="ident">Write_e_dissolution_txt</span></span>(<span>dict_sample, dict_sollicitations)</span>
</code></dt>
<dd>
<div class="desc"><p>Write an .txt file for MOOSE. This file described an homogenous dissolution field.</p>
<p>Input :
a sample dictionnary (a dict)
a sollicitations dictionnary (a dict)
Output :
Nothing, but a .txt file is generated (a file)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Write_e_dissolution_txt(dict_sample,dict_sollicitations):
      &#34;&#34;&#34;
      Write an .txt file for MOOSE. This file described an homogenous dissolution field.

        Input :
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
        Output :
            Nothing, but a .txt file is generated (a file)
      &#34;&#34;&#34;
      #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
      #Load data needed
      x_L = dict_sample[&#39;x_L&#39;]
      y_L = dict_sample[&#39;y_L&#39;]
      e_dissolution = dict_sollicitations[&#39;Dissolution_Energy&#39;]
      #-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

      file_to_write = open(&#39;Data/e_dissolution.txt&#39;,&#39;w&#39;)
      file_to_write.write(&#39;AXIS X\n&#39;)
      line = &#39;&#39;
      for x in x_L:
          line = line + str(x)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;AXIS Y\n&#39;)
      line = &#39;&#39;
      for y in y_L:
        line = line + str(y)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;DATA\n&#39;)
      for l in range(len(y_L)):
          for c in range(len(x_L)):
              file_to_write.write(str(e_dissolution)+&#39;\n&#39;)

      file_to_write.close()</code></pre>
</details>
</dd>
<dt id="Owntools.error_on_ymax_df"><code class="name flex">
<span>def <span class="ident">error_on_ymax_df</span></span>(<span>dy, overlap_L, k_L)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the derivative function df to control the upper wall (error_on_ymax_f()).</p>
<pre><code>Input :
    an increment of the upper wall position (a float)
    a list of overlap for contact between grain and upper wall (a list)
    a list of spring for contact between grain and upper wall (a list)
Output :
    the derivative of error_on_ymax_f() (a float)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_on_ymax_df(dy,overlap_L,k_L) :
    &#34;&#34;&#34;
    Compute the derivative function df to control the upper wall (error_on_ymax_f()).

        Input :
            an increment of the upper wall position (a float)
            a list of overlap for contact between grain and upper wall (a list)
            a list of spring for contact between grain and upper wall (a list)
        Output :
            the derivative of error_on_ymax_f() (a float)
    &#34;&#34;&#34;
    df = 0
    for i in range(len(overlap_L)):
        df = df + 3/2*k_L[i]*(max(overlap_L[i]-dy,0))**(1/2)
    return df</code></pre>
</details>
</dd>
<dt id="Owntools.error_on_ymax_f"><code class="name flex">
<span>def <span class="ident">error_on_ymax_f</span></span>(<span>dy, overlap_L, k_L, Force_target)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the function f to control the upper wall. It is the difference between the force applied and the target value.</p>
<pre><code>Input :
    an increment of the upper wall position (a float)
    a list of overlap for contact between grain and upper wall (a list)
    a list of spring for contact between grain and upper wall (a list)
    a confinement force (a float)
Output :
    the difference between the force applied and the confinement (a float)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_on_ymax_f(dy,overlap_L,k_L,Force_target) :
    &#34;&#34;&#34;
    Compute the function f to control the upper wall. It is the difference between the force applied and the target value.

        Input :
            an increment of the upper wall position (a float)
            a list of overlap for contact between grain and upper wall (a list)
            a list of spring for contact between grain and upper wall (a list)
            a confinement force (a float)
        Output :
            the difference between the force applied and the confinement (a float)
    &#34;&#34;&#34;
    f = Force_target
    for i in range(len(overlap_L)):
        f = f - k_L[i]*(max(overlap_L[i]-dy,0))**(3/2)
    return f</code></pre>
</details>
</dd>
<dt id="Owntools.index_to_str"><code class="name flex">
<span>def <span class="ident">index_to_str</span></span>(<span>j)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an integer to a float with 3 components</p>
<p>Input :
an integer (a int)
Output :
a string (a string)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_to_str(j):
      &#34;&#34;&#34;
      Convert an integer to a float with 3 components

        Input :
            an integer (a int)
        Output :
            a string (a string)
      &#34;&#34;&#34;
      if j &lt; 10:
          j_str = &#39;00&#39;+str(j)
      elif 10 &lt;= j and j &lt; 100:
          j_str = &#39;0&#39;+str(j)
      else :
          j_str = str(j)
      return j_str</code></pre>
</details>
</dd>
<dt id="Owntools.make_mp4"><code class="name flex">
<span>def <span class="ident">make_mp4</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>The goal of this function is to create a movie with all configuration pictures.</p>
<p>From <a href="https://www.blog.pythonlibrary.org/2021/06/23/creating-an-animated-gif-with-python/">https://www.blog.pythonlibrary.org/2021/06/23/creating-an-animated-gif-with-python/</a></p>
<pre><code>Input :
    Nothing
Output :
    Nothing, but a .mp4 file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_mp4():
    &#34;&#34;&#34;
    The goal of this function is to create a movie with all configuration pictures.

    From https://www.blog.pythonlibrary.org/2021/06/23/creating-an-animated-gif-with-python/

        Input :
            Nothing
        Output :
            Nothing, but a .mp4 file is generated (a file)
    &#34;&#34;&#34;
    #look for the largest iteration
    template_name = &#39;Debug/DEM_ite/PF_ite_&#39;
    i_f = 0
    plotpath = Path(template_name+str(i_f)+&#39;.png&#39;)
    while plotpath.exists():
        i_f = i_f + 1
        plotpath = Path(template_name+str(i_f)+&#39;.png&#39;)

    fileList = []
    for i in range(0,i_f):
        fileList.append(template_name+str(i)+&#39;.png&#39;)

    duration_movie  = 10 #sec
    writer = imageio.get_writer(&#39;Debug/PF_ite.mp4&#39;, fps=int(i_f/duration_movie))
    for im in fileList:
        writer.append_data(imageio.imread(im))
    writer.close()</code></pre>
</details>
</dd>
<dt id="Owntools.save_DEM_final"><code class="name flex">
<span>def <span class="ident">save_DEM_final</span></span>(<span>dict_algorithm, dict_sample, dict_sollicitations, dict_tracker)</span>
</code></dt>
<dd>
<div class="desc"><p>Save trackers and configuration at the end of DEM iteration.</p>
<pre><code>Input :
    an algorithm dictionnary (a dict)
    a sample dictionnary (a dict)
    a sollicitations dictionnary (a dict)
    a tracker dictionnary (a dict)
Output :
    Nothing, but a save file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_DEM_final(dict_algorithm,dict_sample,dict_sollicitations,dict_tracker):
    &#34;&#34;&#34;
    Save trackers and configuration at the end of DEM iteration.

        Input :
            an algorithm dictionnary (a dict)
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    os.remove(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/save_tempo&#39;)
    outfile = open(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/save&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;E_cin_stop&#39;] = dict_algorithm[&#39;Ecin_stop&#39;]
    dict_save[&#39;n_window_stop&#39;] = dict_algorithm[&#39;n_window_stop&#39;]
    dict_save[&#39;dy_box_max_stop&#39;] = dict_algorithm[&#39;dy_box_max_stop&#39;]
    dict_save[&#39;dk0_stop&#39;] = dict_algorithm[&#39;dk0_stop&#39;]
    dict_save[&#39;L_g&#39;] = dict_sample[&#39;L_g&#39;]
    dict_save[&#39;L_contact&#39;] = dict_sample[&#39;L_contact&#39;]
    dict_save[&#39;L_ij_contact&#39;] = dict_sample[&#39;L_ij_contact&#39;]
    dict_save[&#39;L_contact_gw&#39;] = dict_sample[&#39;L_contact_gw&#39;]
    dict_save[&#39;L_ij_contact_gw&#39;] = dict_sample[&#39;L_ij_contact_gw&#39;]
    dict_save[&#39;F_on_ymax&#39;] = dict_sollicitations[&#39;Force_on_upper_wall&#39;]
    dict_save[&#39;E_cin&#39;] = dict_tracker[&#39;Ecin&#39;]
    dict_save[&#39;Force&#39;] = dict_tracker[&#39;Force_applied&#39;]
    dict_save[&#39;k0_xmin_tracker&#39;] = dict_tracker[&#39;k0_xmin&#39;]
    dict_save[&#39;k0_xmax_tracker&#39;] = dict_tracker[&#39;k0_xmax&#39;]
    dict_save[&#39;y_box_max&#39;] = dict_tracker[&#39;y_box_max&#39;][:-1]
    pickle.dump(dict_save,outfile)
    outfile.close()</code></pre>
</details>
</dd>
<dt id="Owntools.save_DEM_tempo"><code class="name flex">
<span>def <span class="ident">save_DEM_tempo</span></span>(<span>dict_algorithm, dict_sample, dict_sollicitations, dict_tracker)</span>
</code></dt>
<dd>
<div class="desc"><p>Save trackers and configuration during DEM interations.</p>
<pre><code>Input :
    an algorithm dictionnary (a dict)
    a sample dictionnary (a dict)
    a sollicitations dictionnary (a dict)
    a tracker dictionnary (a dict)
Output :
    Nothing, but a save file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_DEM_tempo(dict_algorithm,dict_sample,dict_sollicitations,dict_tracker):
    &#34;&#34;&#34;
    Save trackers and configuration during DEM interations.

        Input :
            an algorithm dictionnary (a dict)
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    outfile = open(&#39;Debug/DEM_ite/PF_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;/save_tempo&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;E_cin_stop&#39;] = dict_algorithm[&#39;Ecin_stop&#39;]
    dict_save[&#39;n_window_stop&#39;] = dict_algorithm[&#39;n_window_stop&#39;]
    dict_save[&#39;dy_box_max_stop&#39;] = dict_algorithm[&#39;dy_box_max_stop&#39;]
    dict_save[&#39;dk0_stop&#39;] = dict_algorithm[&#39;dk0_stop&#39;]
    dict_save[&#39;L_g&#39;] = dict_sample[&#39;L_g&#39;]
    dict_save[&#39;L_contact&#39;] = dict_sample[&#39;L_contact&#39;]
    dict_save[&#39;L_ij_contact&#39;] = dict_sample[&#39;L_ij_contact&#39;]
    dict_save[&#39;L_contact_gw&#39;] = dict_sample[&#39;L_contact_gw&#39;]
    dict_save[&#39;L_ij_contact_gw&#39;] = dict_sample[&#39;L_ij_contact_gw&#39;]
    dict_save[&#39;F_on_ymax&#39;] = dict_sollicitations[&#39;Force_on_upper_wall&#39;]
    dict_save[&#39;E_cin&#39;] = dict_tracker[&#39;Ecin&#39;]
    dict_save[&#39;Force&#39;] = dict_tracker[&#39;Force_applied&#39;]
    dict_save[&#39;k0_xmin_tracker&#39;] = dict_tracker[&#39;k0_xmin&#39;]
    dict_save[&#39;k0_xmax_tracker&#39;] = dict_tracker[&#39;k0_xmax&#39;]
    dict_save[&#39;y_box_max&#39;] = dict_tracker[&#39;y_box_max&#39;][:-1]
    pickle.dump(dict_save,outfile)
    outfile.close()</code></pre>
</details>
</dd>
<dt id="Owntools.save_dicts"><code class="name flex">
<span>def <span class="ident">save_dicts</span></span>(<span>dict_algorithm, dict_geometry, dict_material, dict_sample, dict_sollicitations, dict_tracker)</span>
</code></dt>
<dd>
<div class="desc"><p>Save dictionnaries at the end of PFDEM iteration.</p>
<pre><code>Input :
    an algorithm dictionnary (a dict)
    a geometry dictionnary (a dict)
    a material dictionnary (a dict)
    a sample dictionnary (a dict)
    a sollicitations dictionnary (a dict)
    a tracker dictionnary (a dict)
Output :
    Nothing, but a save file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_dicts(dict_algorithm, dict_geometry, dict_material, dict_sample, dict_sollicitations, dict_tracker):
    &#34;&#34;&#34;
    Save dictionnaries at the end of PFDEM iteration.

        Input :
            an algorithm dictionnary (a dict)
            a geometry dictionnary (a dict)
            a material dictionnary (a dict)
            a sample dictionnary (a dict)
            a sollicitations dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    outfile = open(dict_algorithm[&#39;name_folder&#39;]+&#39;_save_dicts&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;algorithm&#39;] = dict_algorithm
    dict_save[&#39;geometry&#39;] = dict_geometry
    dict_save[&#39;material&#39;] = dict_material
    dict_save[&#39;sample&#39;] = dict_sample
    dict_save[&#39;sollicitations&#39;] = dict_sollicitations
    dict_save[&#39;tracker&#39;] = dict_tracker
    pickle.dump(dict_save,outfile)
    outfile.close()</code></pre>
</details>
</dd>
<dt id="Owntools.save_final"><code class="name flex">
<span>def <span class="ident">save_final</span></span>(<span>dict_algorithm, dict_tracker)</span>
</code></dt>
<dd>
<div class="desc"><p>Save trackers and configuration at the end of simulation.</p>
<pre><code>Input :
    an algorithm dictionnary (a dict)
    a tracker dictionnary (a dict)
Output :
    Nothing, but a save file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_final(dict_algorithm,dict_tracker):
    &#34;&#34;&#34;
    Save trackers and configuration at the end of simulation.

        Input :
            an algorithm dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    os.remove(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_save_tempo&#39;)
    outfile = open(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_save&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;k0_xmin_L&#39;] = dict_tracker[&#39;k0_xmin_L&#39;]
    dict_save[&#39;k0_xmax_L&#39;] = dict_tracker[&#39;k0_xmax_L&#39;]
    dict_save[&#39;S_dissolved_L&#39;] = dict_tracker[&#39;S_dissolved_L&#39;]
    dict_save[&#39;S_dissolved_perc_L&#39;] = dict_tracker[&#39;S_dissolved_perc_L&#39;]
    dict_save[&#39;S_grains_L&#39;] = dict_tracker[&#39;S_grains_L&#39;]
    pickle.dump(dict_save,outfile)
    outfile.close()</code></pre>
</details>
</dd>
<dt id="Owntools.save_tempo"><code class="name flex">
<span>def <span class="ident">save_tempo</span></span>(<span>dict_algorithm, dict_tracker)</span>
</code></dt>
<dd>
<div class="desc"><p>Save trackers and configuration during
PFDEM iteration.</p>
<pre><code>Input :
    an algorithm dictionnary (a dict)
    a tracker dictionnary (a dict)
Output :
    Nothing, but a save file is generated (a file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_tempo(dict_algorithm,dict_tracker):
    &#34;&#34;&#34;
    Save trackers and configuration during  PFDEM iteration.

        Input :
            an algorithm dictionnary (a dict)
            a tracker dictionnary (a dict)
        Output :
            Nothing, but a save file is generated (a file)
    &#34;&#34;&#34;
    outfile = open(&#39;../&#39;+dict_algorithm[&#39;main_folder_name&#39;]+&#39;/&#39;+dict_algorithm[&#39;name_folder&#39;]+&#39;_save_tempo&#39;,&#39;wb&#39;)
    dict_save = {}
    dict_save[&#39;k0_xmin_L&#39;] = dict_tracker[&#39;k0_xmin_L&#39;]
    dict_save[&#39;k0_xmax_L&#39;] = dict_tracker[&#39;k0_xmax_L&#39;]
    dict_save[&#39;S_dissolved_L&#39;] = dict_tracker[&#39;S_dissolved_L&#39;]
    dict_save[&#39;S_dissolved_perc_L&#39;] = dict_tracker[&#39;S_dissolved_perc_L&#39;]
    dict_save[&#39;S_grains_L&#39;] = dict_tracker[&#39;S_grains_L&#39;]
    pickle.dump(dict_save,outfile)
    outfile.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Owntools.Contact_gw_pp"><code class="flex name class">
<span>class <span class="ident">Contact_gw_pp</span></span>
<span>(</span><span>Id_g, L_g, Nature, Limit, Normal)</span>
</code></dt>
<dd>
<div class="desc"><p>Defining a contact grain-wall for the postprocess.</p>
<pre><code>Input :
    itself (a contact_gw_pp)
    a id of the grain (a float)
    the list of the post process grain (a list)
    the nature of the wall (a string)
    the value of normal reaction of the contact (a float)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Contact_gw_pp:

    def __init__(self, Id_g, L_g, Nature, Limit, Normal):
        &#34;&#34;&#34;
        Defining a contact grain-wall for the postprocess.

            Input :
                itself (a contact_gw_pp)
                a id of the grain (a float)
                the list of the post process grain (a list)
                the nature of the wall (a string)
                the value of normal reaction of the contact (a float)
        &#34;&#34;&#34;
        for g in L_g:
            if g.id == Id_g:
                self.g = g
        self.nature = Nature
        self.limit = Limit
        self.normal = Normal

    def plot(self, normal_ref):
        &#34;&#34;&#34;
        Prepare the chain force plot.

            Input :
                itself (a contact_gw_pp)
                a reference value (a float)
            Output :
                Nothing, but the post process contact gets the ratio of the normal force with the reference value as a new attribut (a float)
        &#34;&#34;&#34;
        if self.nature == &#39;gwx_min&#39; or self.nature == &#39;gwx_max&#39;:
            virtual_center = [self.limit, self.g.center[1]]
        elif self.nature == &#39;gwy_min&#39; or self.nature == &#39;gwy_max&#39;:
            virtual_center = [ self.g.center[0], self.limit]
        L_x = [self.g.center[0], virtual_center[0]]
        L_y = [self.g.center[1], virtual_center[1]]
        ratio_normal = self.normal/normal_ref
        return L_x, L_y, ratio_normal</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Owntools.Contact_gw_pp.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, normal_ref)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the chain force plot.</p>
<pre><code>Input :
    itself (a contact_gw_pp)
    a reference value (a float)
Output :
    Nothing, but the post process contact gets the ratio of the normal force with the reference value as a new attribut (a float)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, normal_ref):
    &#34;&#34;&#34;
    Prepare the chain force plot.

        Input :
            itself (a contact_gw_pp)
            a reference value (a float)
        Output :
            Nothing, but the post process contact gets the ratio of the normal force with the reference value as a new attribut (a float)
    &#34;&#34;&#34;
    if self.nature == &#39;gwx_min&#39; or self.nature == &#39;gwx_max&#39;:
        virtual_center = [self.limit, self.g.center[1]]
    elif self.nature == &#39;gwy_min&#39; or self.nature == &#39;gwy_max&#39;:
        virtual_center = [ self.g.center[0], self.limit]
    L_x = [self.g.center[0], virtual_center[0]]
    L_y = [self.g.center[1], virtual_center[1]]
    ratio_normal = self.normal/normal_ref
    return L_x, L_y, ratio_normal</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Owntools.Contact_pp"><code class="flex name class">
<span>class <span class="ident">Contact_pp</span></span>
<span>(</span><span>Id_g1, Id_g2, L_g, Normal)</span>
</code></dt>
<dd>
<div class="desc"><p>Defining a contact grain - grain for the postprocess.</p>
<pre><code>Input :
    itself (a contact_pp)
    the ids of the grains (two int)
    a list of post process grains (a list)
    the value of normal reaction of the contact (a float)
Output :
    Nothing, but a post process contact grain - grain is generated
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Contact_pp:

    def __init__(self, Id_g1, Id_g2, L_g, Normal):
        &#34;&#34;&#34;
        Defining a contact grain - grain for the postprocess.

            Input :
                itself (a contact_pp)
                the ids of the grains (two int)
                a list of post process grains (a list)
                the value of normal reaction of the contact (a float)
            Output :
                Nothing, but a post process contact grain - grain is generated
        &#34;&#34;&#34;
        for g in L_g:
            if g.id == Id_g1:
                self.g1 = g
            elif g.id == Id_g2:
                self.g2 = g
        self.normal = Normal

    def plot(self, normal_ref):
        &#34;&#34;&#34;
        Prepare the chain force plot.

            Input :
                itself (a contact_pp)
                a reference value (a float)
            Output :
                Nothing, but the post process contact gets the ratio of the normal force with the reference value as a new attribut (a float)
        &#34;&#34;&#34;
        L_x = [self.g1.center[0], self.g2.center[0]]
        L_y = [self.g1.center[1], self.g2.center[1]]
        ratio_normal = self.normal/normal_ref
        return L_x, L_y, ratio_normal</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Owntools.Contact_pp.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, normal_ref)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the chain force plot.</p>
<pre><code>Input :
    itself (a contact_pp)
    a reference value (a float)
Output :
    Nothing, but the post process contact gets the ratio of the normal force with the reference value as a new attribut (a float)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, normal_ref):
    &#34;&#34;&#34;
    Prepare the chain force plot.

        Input :
            itself (a contact_pp)
            a reference value (a float)
        Output :
            Nothing, but the post process contact gets the ratio of the normal force with the reference value as a new attribut (a float)
    &#34;&#34;&#34;
    L_x = [self.g1.center[0], self.g2.center[0]]
    L_y = [self.g1.center[1], self.g2.center[1]]
    ratio_normal = self.normal/normal_ref
    return L_x, L_y, ratio_normal</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Owntools.Grain_pp"><code class="flex name class">
<span>class <span class="ident">Grain_pp</span></span>
<span>(</span><span>Id, Dissolved, Center, Coordinate_x, Coordinate_y)</span>
</code></dt>
<dd>
<div class="desc"><p>Defining a grain for the postprocess</p>
<pre><code>Input :
    itself (a grain_pp)
    an id (a int)
    a Boolean to know if the grain is dissolvable (a Boolean)
    a center (a 1 x 2 numpy array)
    two lists of vertices coordinates x and y (two lists)
Output :
    Nothing, but a post process grain is generated
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grain_pp:

    def __init__(self, Id, Dissolved, Center, Coordinate_x, Coordinate_y):
        &#34;&#34;&#34;
        Defining a grain for the postprocess

            Input :
                itself (a grain_pp)
                an id (a int)
                a Boolean to know if the grain is dissolvable (a Boolean)
                a center (a 1 x 2 numpy array)
                two lists of vertices coordinates x and y (two lists)
            Output :
                Nothing, but a post process grain is generated
        &#34;&#34;&#34;
        self.id = Id
        self.dissolved = Dissolved
        self.center = Center
        self.coordinate_x = Coordinate_x
        self.coordinate_y = Coordinate_y</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Owntools.Compute_k0" href="#Owntools.Compute_k0">Compute_k0</a></code></li>
<li><code><a title="Owntools.Control_y_max_NR" href="#Owntools.Control_y_max_NR">Control_y_max_NR</a></code></li>
<li><code><a title="Owntools.Debug_DEM_f" href="#Owntools.Debug_DEM_f">Debug_DEM_f</a></code></li>
<li><code><a title="Owntools.Debug_Trackers" href="#Owntools.Debug_Trackers">Debug_Trackers</a></code></li>
<li><code><a title="Owntools.Debug_Trackers_DEM" href="#Owntools.Debug_Trackers_DEM">Debug_Trackers_DEM</a></code></li>
<li><code><a title="Owntools.Debug_configuration" href="#Owntools.Debug_configuration">Debug_configuration</a></code></li>
<li><code><a title="Owntools.Plot_chain_force" href="#Owntools.Plot_chain_force">Plot_chain_force</a></code></li>
<li><code><a title="Owntools.Reset_y_max" href="#Owntools.Reset_y_max">Reset_y_max</a></code></li>
<li><code><a title="Owntools.Sort_Files" href="#Owntools.Sort_Files">Sort_Files</a></code></li>
<li><code><a title="Owntools.Stop_Debug" href="#Owntools.Stop_Debug">Stop_Debug</a></code></li>
<li><code><a title="Owntools.Write_e_dissolution_txt" href="#Owntools.Write_e_dissolution_txt">Write_e_dissolution_txt</a></code></li>
<li><code><a title="Owntools.error_on_ymax_df" href="#Owntools.error_on_ymax_df">error_on_ymax_df</a></code></li>
<li><code><a title="Owntools.error_on_ymax_f" href="#Owntools.error_on_ymax_f">error_on_ymax_f</a></code></li>
<li><code><a title="Owntools.index_to_str" href="#Owntools.index_to_str">index_to_str</a></code></li>
<li><code><a title="Owntools.make_mp4" href="#Owntools.make_mp4">make_mp4</a></code></li>
<li><code><a title="Owntools.save_DEM_final" href="#Owntools.save_DEM_final">save_DEM_final</a></code></li>
<li><code><a title="Owntools.save_DEM_tempo" href="#Owntools.save_DEM_tempo">save_DEM_tempo</a></code></li>
<li><code><a title="Owntools.save_dicts" href="#Owntools.save_dicts">save_dicts</a></code></li>
<li><code><a title="Owntools.save_final" href="#Owntools.save_final">save_final</a></code></li>
<li><code><a title="Owntools.save_tempo" href="#Owntools.save_tempo">save_tempo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Owntools.Contact_gw_pp" href="#Owntools.Contact_gw_pp">Contact_gw_pp</a></code></h4>
<ul class="">
<li><code><a title="Owntools.Contact_gw_pp.plot" href="#Owntools.Contact_gw_pp.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Owntools.Contact_pp" href="#Owntools.Contact_pp">Contact_pp</a></code></h4>
<ul class="">
<li><code><a title="Owntools.Contact_pp.plot" href="#Owntools.Contact_pp.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Owntools.Grain_pp" href="#Owntools.Grain_pp">Grain_pp</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>