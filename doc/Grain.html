<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Grain API documentation</title>
<meta name="description" content="@author: Alexandre Sac--Morane
alexandre.sac-morane@uclouvain.be …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Grain</code></h1>
</header>
<section id="section-intro">
<p>@author: Alexandre Sac&ndash;Morane
alexandre.sac-morane@uclouvain.be</p>
<p>The goal of this file is to define a new class.
The new class is about the grains</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
@author: Alexandre Sac--Morane
alexandre.sac-morane@uclouvain.be

The goal of this file is to define a new class.
The new class is about the grains
&#34;&#34;&#34;

#-------------------------------------------------------------------------------
#Libs
#-------------------------------------------------------------------------------

import numpy as np
import math
import random

#-------------------------------------------------------------------------------
#Class
#-------------------------------------------------------------------------------

class Grain:

#-------------------------------------------------------------------------------

  def __init__(self, dict_ic_to_real, Id_Eta = None, V = np.array([0,0]), A = np.array([0,0])):
    &#34;&#34;&#34;
    Defining the grain.

    The ic to real dictionnary is the data transmission between the temporary grain and the real one.
        Input :
            itself (a grain)
            a ic to real dictionnary (a dict)
        Output :
            a grain is generated (a grain)
    &#34;&#34;&#34;
    #Id of the grain
    self.id = dict_ic_to_real[&#39;Id&#39;]
    self.id_eta = Id_Eta
    #Material property
    self.dissolved = dict_ic_to_real[&#39;Type&#39;] == &#39;Square&#39;
    self.y = dict_ic_to_real[&#39;Y&#39;]
    self.nu = dict_ic_to_real[&#39;Nu&#39;]
    self.g = self.y /2/(1+self.nu) #shear modulus
    self.rho_surf = dict_ic_to_real[&#39;Rho_surf&#39;]
    #kinematic
    self.v = V
    self.a = A
    self.theta = 0
    self.w = 0 #dtheta/dt
    #position
    self.center = dict_ic_to_real[&#39;Center&#39;]
    self.l_border = dict_ic_to_real[&#39;L_border&#39;]
    self.l_border_x = dict_ic_to_real[&#39;L_border_x&#39;]
    self.l_border_y = dict_ic_to_real[&#39;L_border_y&#39;]
    #characteristic
    self.l_r = dict_ic_to_real[&#39;L_r&#39;]
    self.l_theta_r = dict_ic_to_real[&#39;L_theta_r&#39;]
    self.r_min = dict_ic_to_real[&#39;R_min&#39;]
    self.r_max = dict_ic_to_real[&#39;R_max&#39;]
    self.r_mean = dict_ic_to_real[&#39;R_mean&#39;]
    self.surface = dict_ic_to_real[&#39;Surface&#39;]
    self.m = dict_ic_to_real[&#39;Mass&#39;]
    self.inertia = dict_ic_to_real[&#39;Inertia&#39;]

#-------------------------------------------------------------------------------

  def update_geometry_kinetic(self, V, A, W, DT):
    &#34;&#34;&#34;
    Update the acceleration and the velocity of a grain. Update geometrical parameters as border and center nodes.

        Input :
            itself (a grain)
            a speed (a 1 x 2 numpy array)
            an acceleration (a 1 x 2 numpy array)
            an angular speed (a float)
            a time step (a float)
        Ouput :
            Nothing, but the position of the grain is updated
    &#34;&#34;&#34;
    #translation
    self.v = V
    self.a = A
    for i in range(len(self.l_border)):
        self.l_border[i] = self.l_border[i] + self.v*DT
        self.l_border_x[i] = self.l_border_x[i] + self.v[0]*DT
        self.l_border_y[i] = self.l_border_y[i] + self.v[1]*DT
    self.center = self.center + self.v*DT

    #rotation
    self.w = W
    self.theta = self.theta + self.w*DT

    for i_theta_r in range(len(self.l_theta_r)) :
        theta_r = self.l_theta_r[i_theta_r]
        theta_r = theta_r + self.w*DT
        while theta_r &gt;= 2*math.pi:
            theta_r = theta_r - 2*math.pi
        while theta_r &lt; 0 :
            theta_r = theta_r + 2*math.pi
        self.l_theta_r[i_theta_r] = theta_r

    for i in range(len(self.l_border)):
        p = self.l_border[i] - self.center
        Rot_Matrix = np.array([[math.cos(self.w*DT), -math.sin(self.w*DT)],
                               [math.sin(self.w*DT),  math.cos(self.w*DT)]])
        p = np.dot(Rot_Matrix,p)
        self.l_border[i] = p + self.center
        self.l_border_x[i] = p[0] + self.center[0]
        self.l_border_y[i] = p[1] + self.center[1]

#-------------------------------------------------------------------------------

  def init_f_control(self,dict_sollicitations):
      &#34;&#34;&#34;
      Initialize the force applied to the grain.

      A gravity of g is applied.

        Input :
            itself (a grain)
            a sollicitations dictionnary (a dict)
        Ouput :
            Nothing, but the force applied on the grain is initialized
      &#34;&#34;&#34;
      self.fx = 0
      self.fy = -dict_sollicitations[&#39;gravity&#39;]*self.m
      self.f = np.array([self.fx,self.fy])
      self.mz = 0

#-------------------------------------------------------------------------------

  def update_f(self, Fx, Fy, p_application):
    &#34;&#34;&#34;
    Add a force to the grain.

        Input :
            itself (a grain)
            the value x and y of the force (two float)
            an applicaiton point (a 1 x 2 numpy array)
        Output :
            Nothing, but a force is applied to the grain
    &#34;&#34;&#34;
    self.fx = self.fx + Fx
    self.fy = self.fy + Fy
    self.f = np.array([self.fx,self.fy])

    v1 = np.array([p_application[0]-self.center[0], p_application[1]-self.center[1], 0])
    v2 = np.array([Fx, Fy, 0])
    self.mz = self.mz + np.cross(v1,v2)[2]

#-------------------------------------------------------------------------------

  def Geometricstudy_local(self,dict_geometry,dict_sample,simulation_report):
      &#34;&#34;&#34;
      Searching border of the grain.

      We iterate on y constant, we look for a value under and over 0.5.
      If both conditions are verified, there is a limit at this y
      Same with iteration on x constant.

      Then, searching Surface, Center of mass and Inertia.
      A Monte Carlo Method is applied.
      A box is defined, we take a random point and we look if it is inside or outside the grain.
      Properties are the statistic times the box properties.

        Input :
            itself (a grain)
            a geometry dictionnary (a dict)
            a sample dictionnary (a dict)
            a simulation report (a report)
        Output :
            Nothing, but geometric parameters are updated
      &#34;&#34;&#34;
      #-------------------------------------------------------------------------
      #load data needed
      n = dict_geometry[&#39;grain_discretisation&#39;]
      x_L = self.x_L_local
      y_L = self.y_L_local
      #-------------------------------------------------------------------------

      L_border_old = []
      for y_i in range(len(y_L)):
          L_extract_x = self.etai_M[y_i][:]
          if id == 1:
              L_extract_x = list(L_extract_x)
              L_extract_x.reverse()
          if max(L_extract_x)&gt;0.5 and min(L_extract_x)&lt;0.5:
              y_intersect = y_L[len(y_L)-1-y_i]
              for x_i in range(len(x_L)-1):
                  if (L_extract_x[x_i]-0.5)*(L_extract_x[x_i+1]-0.5)&lt;0:
                      x_intersect = (0.5-L_extract_x[x_i])/(L_extract_x[x_i+1]-L_extract_x[x_i])*\
                                  (x_L[x_i+1]-x_L[x_i]) + x_L[x_i]
                      L_border_old.append(np.array([x_intersect,y_intersect]))

      for x_i in range(len(x_L)):
          L_extract_y = []
          for y_i in range(len(y_L)):
              L_extract_y.append(self.etai_M[y_i][x_i])
          if max(L_extract_y)&gt;0.5 and min(L_extract_y)&lt;0.5:
              x_intersect = x_L[x_i]
              for y_i in range(len(y_L)-1):
                  if (L_extract_y[y_i]-0.5)*(L_extract_y[y_i+1]-0.5)&lt;0:
                      y_intersect = (0.5-L_extract_y[y_i])/(L_extract_y[y_i+1]-L_extract_y[y_i])*\
                                  (y_L[len(y_L)-1-y_i-1]-y_L[len(y_L)-1-y_i]) + y_L[len(y_L)-1-y_i]
                      L_border_old.append(np.array([x_intersect,y_intersect]))

      #Adaptating
      L_id_used = [0]
      L_border = [L_border_old[0]]
      HighValue = 100000000 #Large

      current_node = L_border_old[0]
      for j in range(1,len(L_border_old)):
          L_d = list(np.zeros(len(L_border_old)))
          for i in range(0,len(L_border_old)):
              node = L_border_old[i]
              if  i not in L_id_used:
                  d = np.linalg.norm(node - current_node)
                  L_d[i] = d
              else :
                  L_d[i] = HighValue #Value need to be larger than potential distance between node

          index_nearest_node = L_d.index(min(L_d))
          nearest_node = L_border_old[index_nearest_node]
          current_node = nearest_node
          L_border.append(nearest_node)
          L_id_used.append(index_nearest_node)

      #Correcting
      L_d_final = []
      for i in range(len(L_border)-1):
          L_d_final.append(np.linalg.norm(L_border[i+1] - L_border[i]))

      #look for really far points, we assume the first point is accurate
      d_final_mean = np.mean(L_d_final)
      while np.max(L_d_final) &gt; 5 * d_final_mean : #5 here is an user choixe value
          i_error = L_d_final.index(np.max(L_d_final))+1
          simulation_report.write(&#39;Point &#39;+str(L_border[i_error])+&#39; is deleted because it is detected as an error\n&#39;)
          L_border.pop(i_error)
          L_id_used.pop(i_error)
          L_d_final = []
          for i in range(len(L_border)-1):
              L_d_final.append(np.linalg.norm(L_border[i+1] - L_border[i]))

      #-------------------------------------------------------------------------------
      #Reduce the number of nodes for a grain
      #-------------------------------------------------------------------------------

      Perimeter = 0
      for i_p in range(len(L_border)-1):
          Perimeter = Perimeter + np.linalg.norm(L_border[i_p+1]-L_border[i_p])
      Perimeter = Perimeter + np.linalg.norm(L_border[-1]-L_border[0])
      distance_min = Perimeter/n
      L_border_adapted = [L_border[0]]
      for p in L_border[1:]:
          distance = np.linalg.norm(p-L_border_adapted[-1])
          if distance &gt;= distance_min:
              L_border_adapted.append(p)
      L_border = L_border_adapted
      L_border.append(L_border[0])
      self.l_border = L_border

      #-------------------------------------------------------------------------------
      #Monte carlo method
      #-------------------------------------------------------------------------------

      min_max_defined = False
      for p in L_border[:-1] :
          if not min_max_defined:
              box_min_x = p[0]
              box_max_x = p[0]
              box_min_y = p[1]
              box_max_y = p[1]
              min_max_defined = True
          else:
              if p[0] &lt; box_min_x:
                  box_min_x = p[0]
              elif p[0] &gt; box_max_x:
                  box_max_x = p[0]
              if p[1] &lt; box_min_y:
                  box_min_y = p[1]
              elif p[1] &gt; box_max_y:
                  box_max_y = p[1]

      N_MonteCarlo = 3000 #The larger it is, the more accurate it is
      sigma = self.rho_surf #kg/µm2
      M_Mass = 0
      M_Center_Mass = np.array([0,0])
      M_Inertia = 0

      for i in range(N_MonteCarlo):
          P = np.array([random.uniform(box_min_x,box_max_x),random.uniform(box_min_y,box_max_y)])
          if self.P_is_inside(P):
              M_Mass = M_Mass + sigma
              M_Center_Mass = M_Center_Mass + sigma*P
              M_Inertia = M_Inertia + sigma*np.dot(P,P)

      Mass = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Mass
      Center_Mass = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Center_Mass/Mass
      Inertia = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Inertia-Mass*np.dot(Center_Mass,Center_Mass)

      #-------------------------------------------------------------------------------
      #Updating the grain geometry and properties
      #-------------------------------------------------------------------------------

      L_R = []
      L_theta_R = []
      L_border_x = []
      L_border_y = []
      for p in L_border[:-1]:
          L_R.append(np.linalg.norm(p-Center_Mass))
          L_border_x.append(p[0])
          L_border_y.append(p[1])
          if (p-Center_Mass)[1] &gt; 0:
              theta = math.acos((p-Center_Mass)[0]/np.linalg.norm(p-Center_Mass))
          else :
              theta = 2*math.pi - math.acos((p-Center_Mass)[0]/np.linalg.norm(p-Center_Mass))
          L_theta_R.append(theta)
      L_border_x.append(L_border_x[0])
      L_border_y.append(L_border_y[0])
      #reorganize lists
      L_R.reverse()
      L_theta_R.reverse()
      i_min_theta = L_theta_R.index(min(L_theta_R))
      L_R = L_R[i_min_theta:]+L_R[:i_min_theta]
      L_theta_R = L_theta_R[i_min_theta:]+L_theta_R[:i_min_theta]

      self.r_min = np.min(L_R)
      self.r_max = np.max(L_R)
      self.r_mean = np.mean(L_R)
      self.l_r = L_R
      self.l_theta_r = L_theta_R
      self.surface = Mass/self.rho_surf
      self.m = Mass
      self.center = Center_Mass
      self.l_border_x = L_border_x
      self.l_border_y = L_border_y
      self.inertia = Inertia

#-------------------------------------------------------------------------------

  def P_is_inside(self,P):
      &#34;&#34;&#34;
      Determine if a point P is inside a grain.

      See Franklin 1994, see Alonso-Marroquin 2009

        Input :
            itself (a grain)
            a point (a 1 x 2 numpy array)
        Output :
            a Boolean, True if the point is inside the grain (a Boolean²)
      &#34;&#34;&#34;
      counter = 0
      for i_p_border in range(len(self.l_border)-1):
          #consider only points if the coordinates frame the y-coordinate of the point
          if (self.l_border[i_p_border][1]-P[1])*(self.l_border[i_p_border+1][1]-P[1]) &lt; 0 :
            x_border = self.l_border[i_p_border][0] + (self.l_border[i_p_border+1][0]-self.l_border[i_p_border][0])*(P[1]-self.l_border[i_p_border][1])/(self.l_border[i_p_border+1][1]-self.l_border[i_p_border][1])
            if x_border &gt; P[0] :
                counter = counter + 1
      if counter % 2 == 0:
        return False
      else :
        return True

#-------------------------------------------------------------------------------

  def Write_e_dissolution_local_txt(self,dict_algorithm,dict_sollicitations):
      &#34;&#34;&#34;
      Write an .txt file for MOOSE. This file described an homogenous dissolution field.

        Input :
            itself (a grain)
            an algorithm dictionnary (a dict)
            a sollicitations dictionnary (a dict)
        Output :
            Nothing, but a .txt file is generated (a file)
      &#34;&#34;&#34;
      file_to_write = open(f&#34;Data/e_diss_g{self.id}_ite{dict_algorithm[&#39;i_PF&#39;]}.txt&#34;,&#39;w&#39;)
      file_to_write.write(&#39;AXIS X\n&#39;)
      line = &#39;&#39;
      for x in self.x_L_local:
          line = line + str(x)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;AXIS Y\n&#39;)
      line = &#39;&#39;
      for y in self.y_L_local:
        line = line + str(y)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;DATA\n&#39;)
      for l in range(len(self.y_L_local)):
          for c in range(len(self.x_L_local)):
              file_to_write.write(str(dict_sollicitations[&#39;Dissolution_Energy&#39;])+&#39;\n&#39;)

      file_to_write.close()

#-------------------------------------------------------------------------------

  def Compute_etaiM_local(self,dict_algorithm,dict_material):
      &#34;&#34;&#34;
      From the grain geometry the phase variable is rebuilt.

      The distance between the point of the mesh and the particle center determines the value of the variable
      A cosine profile is applied inside the interface

        Input :
            itself (a grain)
            an algorithm dictionnary (a dict)
            a material dictionnary (a dict)
        Output :
            Nothing, but the grain gets an updated phase field (a nx x ny numpy array)
      &#34;&#34;&#34;
      x_min_local = min(self.l_border_x)-dict_material[&#39;w&#39;]
      x_max_local = max(self.l_border_x)+dict_material[&#39;w&#39;]
      y_min_local = min(self.l_border_y)-dict_material[&#39;w&#39;]
      y_max_local = max(self.l_border_y)+dict_material[&#39;w&#39;]
      x_L_local = np.arange(x_min_local,x_max_local+dict_algorithm[&#39;dx_local&#39;],dict_algorithm[&#39;dx_local&#39;])
      y_L_local = np.arange(y_min_local,y_max_local+dict_algorithm[&#39;dy_local&#39;],dict_algorithm[&#39;dy_local&#39;])

      self.x_L_local = x_L_local
      self.y_L_local = y_L_local

      # compute phase field
      etai_M = np.array(np.zeros((len(y_L_local),len(x_L_local))))
      for i_x in range(len(x_L_local)):
          for i_y in range(len(y_L_local)):
              p = np.array([x_L_local[i_x],y_L_local[len(y_L_local)-1-i_y]])
              r = np.linalg.norm(self.center - p)
              if p[1]&gt;self.center[1]:
                  theta = math.acos((p[0]-self.center[0])/np.linalg.norm(self.center-p))
              else :
                  theta= 2*math.pi - math.acos((p[0]-self.center[0])/np.linalg.norm(self.center-p))

              L_theta_R_i = list(abs(np.array(self.l_theta_r)-theta))
              R = self.l_r[L_theta_R_i.index(min(L_theta_R_i))]
              #Cosine_Profile
              if r&lt;R-dict_material[&#39;w&#39;]/2:
                  etai_M[i_y][i_x] = 1
              elif r&gt;R+dict_material[&#39;w&#39;]/2:
                  etai_M[i_y][i_x] = 0
              else :
                  etai_M[i_y][i_x] = 0.5*(1 + np.cos(math.pi*(r-R+dict_material[&#39;w&#39;]/2)/dict_material[&#39;w&#39;]))
      self.etai_M = etai_M.copy()

#-------------------------------------------------------------------------------

  def Write_txt_Decons_rebuild_local(self,dict_algorithm):
      &#34;&#34;&#34;
      Write a .txt file. This file is used to define initial condition of MOOSE simulation.

        Input :
            itself (a grain)
            an algorithm dictionnary (a dict)
        Output :
            Nothing, but a .txt file is generated (a file)
      &#34;&#34;&#34;
      file_to_write = open(&#39;Data/g&#39;+str(self.id)+&#39;_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;.txt&#39;,&#39;w&#39;)
      file_to_write.write(&#39;AXIS X\n&#39;)
      line = &#39;&#39;
      for x in self.x_L_local:
          line = line + str(x)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;AXIS Y\n&#39;)
      line = &#39;&#39;
      for y in self.y_L_local:
        line = line + str(y)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;DATA\n&#39;)
      for l in range(len(self.y_L_local)):
          for c in range(len(self.x_L_local)):
              file_to_write.write(str(self.etai_M[-l-1][c])+&#39;\n&#39;)

      file_to_write.close()

#-------------------------------------------------------------------------------

  def PFtoDEM_Multi_local(self,FileToRead,dict_algorithm):
    &#34;&#34;&#34;
    Read data from the moose simulation.

        Input :
            itself (a grain)
            the template of the name to read (a string)
            an algorithm dictionnary (a dict)
        Output :
            Nothing, but the phase field variable is updated (a nx x ny numpy array)
    &#34;&#34;&#34;
    #---------------------------------------------------------------------------
    #Global parameters
    #---------------------------------------------------------------------------

    etai_M = np.zeros((len(self.y_L_local),len(self.x_L_local))) #etai

    id_L = None
    eta_selector_len = len(&#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;etai&#39;)
    end_len = len(&#39;        &lt;/DataArray&gt;&#39;)
    XYZ_selector_len = len(&#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;Points&#34;&#39;)
    data_jump_len = len(&#39;          &#39;)

    for i_proc in range(dict_algorithm[&#39;np_proc&#39;]):

        L_Work = [[], #X
                  [], #Y
                  []] #etai

    #---------------------------------------------------------------------------
    #Reading file
    #---------------------------------------------------------------------------

        f = open(f&#39;{FileToRead}_{i_proc}.vtu&#39;,&#39;r&#39;)
        data = f.read()
        f.close
        lines = data.splitlines()

        #iterations on line
        for line in lines:

            if line[0:eta_selector_len] == &#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;etai&#39;:
                id_L = 2

            elif line[0:XYZ_selector_len] == &#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;Points&#34;&#39;:
                id_L = 0

            elif (line[0:end_len] == &#39;        &lt;/DataArray&gt;&#39; or  line[0:len(&#39;          &lt;InformationKey&#39;)] == &#39;          &lt;InformationKey&#39;) and id_L != None:
                id_L = None

            elif line[0:data_jump_len] == &#39;          &#39; and id_L == 2: #Read etai
                line = line[data_jump_len:]
                c_start = 0
                for c_i in range(0,len(line)):
                    if line[c_i]==&#39; &#39;:
                        c_end = c_i
                        L_Work[id_L].append(float(line[c_start:c_end]))
                        c_start = c_i+1
                L_Work[id_L].append(float(line[c_start:]))

            elif line[0:data_jump_len] == &#39;          &#39; and id_L == 0: #Read [X, Y, Z]
                line = line[data_jump_len:]
                XYZ_temp = []
                c_start = 0
                for c_i in range(0,len(line)):
                    if line[c_i]==&#39; &#39;:
                        c_end = c_i
                        XYZ_temp.append(float(line[c_start:c_end]))
                        if len(XYZ_temp)==3:
                            L_Work[0].append(XYZ_temp[0])
                            L_Work[1].append(XYZ_temp[1])
                            XYZ_temp = []
                        c_start = c_i+1
                XYZ_temp.append(float(line[c_start:]))
                L_Work[0].append(XYZ_temp[0])
                L_Work[1].append(XYZ_temp[1])

        #Adaptating data
        for i in range(len(L_Work[0])):
            #Interpolation method
            L_dy = []
            for y_i in self.y_L_local :
                L_dy.append(abs(y_i - L_Work[1][i]))
            L_dx = []
            for x_i in self.x_L_local :
                L_dx.append(abs(x_i - L_Work[0][i]))
            etai_M[-1-list(L_dy).index(min(L_dy))][list(L_dx).index(min(L_dx))] = L_Work[2][i]

    # Update
    self.etai_M = etai_M.copy()


#-------------------------------------------------------------------------------
#Function
#-------------------------------------------------------------------------------</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Grain.Grain"><code class="flex name class">
<span>class <span class="ident">Grain</span></span>
<span>(</span><span>dict_ic_to_real, Id_Eta=None, V=array([0, 0]), A=array([0, 0]))</span>
</code></dt>
<dd>
<div class="desc"><p>Defining the grain.</p>
<p>The ic to real dictionnary is the data transmission between the temporary grain and the real one.
Input :
itself (a grain)
a ic to real dictionnary (a dict)
Output :
a grain is generated (a grain)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grain:

#-------------------------------------------------------------------------------

  def __init__(self, dict_ic_to_real, Id_Eta = None, V = np.array([0,0]), A = np.array([0,0])):
    &#34;&#34;&#34;
    Defining the grain.

    The ic to real dictionnary is the data transmission between the temporary grain and the real one.
        Input :
            itself (a grain)
            a ic to real dictionnary (a dict)
        Output :
            a grain is generated (a grain)
    &#34;&#34;&#34;
    #Id of the grain
    self.id = dict_ic_to_real[&#39;Id&#39;]
    self.id_eta = Id_Eta
    #Material property
    self.dissolved = dict_ic_to_real[&#39;Type&#39;] == &#39;Square&#39;
    self.y = dict_ic_to_real[&#39;Y&#39;]
    self.nu = dict_ic_to_real[&#39;Nu&#39;]
    self.g = self.y /2/(1+self.nu) #shear modulus
    self.rho_surf = dict_ic_to_real[&#39;Rho_surf&#39;]
    #kinematic
    self.v = V
    self.a = A
    self.theta = 0
    self.w = 0 #dtheta/dt
    #position
    self.center = dict_ic_to_real[&#39;Center&#39;]
    self.l_border = dict_ic_to_real[&#39;L_border&#39;]
    self.l_border_x = dict_ic_to_real[&#39;L_border_x&#39;]
    self.l_border_y = dict_ic_to_real[&#39;L_border_y&#39;]
    #characteristic
    self.l_r = dict_ic_to_real[&#39;L_r&#39;]
    self.l_theta_r = dict_ic_to_real[&#39;L_theta_r&#39;]
    self.r_min = dict_ic_to_real[&#39;R_min&#39;]
    self.r_max = dict_ic_to_real[&#39;R_max&#39;]
    self.r_mean = dict_ic_to_real[&#39;R_mean&#39;]
    self.surface = dict_ic_to_real[&#39;Surface&#39;]
    self.m = dict_ic_to_real[&#39;Mass&#39;]
    self.inertia = dict_ic_to_real[&#39;Inertia&#39;]

#-------------------------------------------------------------------------------

  def update_geometry_kinetic(self, V, A, W, DT):
    &#34;&#34;&#34;
    Update the acceleration and the velocity of a grain. Update geometrical parameters as border and center nodes.

        Input :
            itself (a grain)
            a speed (a 1 x 2 numpy array)
            an acceleration (a 1 x 2 numpy array)
            an angular speed (a float)
            a time step (a float)
        Ouput :
            Nothing, but the position of the grain is updated
    &#34;&#34;&#34;
    #translation
    self.v = V
    self.a = A
    for i in range(len(self.l_border)):
        self.l_border[i] = self.l_border[i] + self.v*DT
        self.l_border_x[i] = self.l_border_x[i] + self.v[0]*DT
        self.l_border_y[i] = self.l_border_y[i] + self.v[1]*DT
    self.center = self.center + self.v*DT

    #rotation
    self.w = W
    self.theta = self.theta + self.w*DT

    for i_theta_r in range(len(self.l_theta_r)) :
        theta_r = self.l_theta_r[i_theta_r]
        theta_r = theta_r + self.w*DT
        while theta_r &gt;= 2*math.pi:
            theta_r = theta_r - 2*math.pi
        while theta_r &lt; 0 :
            theta_r = theta_r + 2*math.pi
        self.l_theta_r[i_theta_r] = theta_r

    for i in range(len(self.l_border)):
        p = self.l_border[i] - self.center
        Rot_Matrix = np.array([[math.cos(self.w*DT), -math.sin(self.w*DT)],
                               [math.sin(self.w*DT),  math.cos(self.w*DT)]])
        p = np.dot(Rot_Matrix,p)
        self.l_border[i] = p + self.center
        self.l_border_x[i] = p[0] + self.center[0]
        self.l_border_y[i] = p[1] + self.center[1]

#-------------------------------------------------------------------------------

  def init_f_control(self,dict_sollicitations):
      &#34;&#34;&#34;
      Initialize the force applied to the grain.

      A gravity of g is applied.

        Input :
            itself (a grain)
            a sollicitations dictionnary (a dict)
        Ouput :
            Nothing, but the force applied on the grain is initialized
      &#34;&#34;&#34;
      self.fx = 0
      self.fy = -dict_sollicitations[&#39;gravity&#39;]*self.m
      self.f = np.array([self.fx,self.fy])
      self.mz = 0

#-------------------------------------------------------------------------------

  def update_f(self, Fx, Fy, p_application):
    &#34;&#34;&#34;
    Add a force to the grain.

        Input :
            itself (a grain)
            the value x and y of the force (two float)
            an applicaiton point (a 1 x 2 numpy array)
        Output :
            Nothing, but a force is applied to the grain
    &#34;&#34;&#34;
    self.fx = self.fx + Fx
    self.fy = self.fy + Fy
    self.f = np.array([self.fx,self.fy])

    v1 = np.array([p_application[0]-self.center[0], p_application[1]-self.center[1], 0])
    v2 = np.array([Fx, Fy, 0])
    self.mz = self.mz + np.cross(v1,v2)[2]

#-------------------------------------------------------------------------------

  def Geometricstudy_local(self,dict_geometry,dict_sample,simulation_report):
      &#34;&#34;&#34;
      Searching border of the grain.

      We iterate on y constant, we look for a value under and over 0.5.
      If both conditions are verified, there is a limit at this y
      Same with iteration on x constant.

      Then, searching Surface, Center of mass and Inertia.
      A Monte Carlo Method is applied.
      A box is defined, we take a random point and we look if it is inside or outside the grain.
      Properties are the statistic times the box properties.

        Input :
            itself (a grain)
            a geometry dictionnary (a dict)
            a sample dictionnary (a dict)
            a simulation report (a report)
        Output :
            Nothing, but geometric parameters are updated
      &#34;&#34;&#34;
      #-------------------------------------------------------------------------
      #load data needed
      n = dict_geometry[&#39;grain_discretisation&#39;]
      x_L = self.x_L_local
      y_L = self.y_L_local
      #-------------------------------------------------------------------------

      L_border_old = []
      for y_i in range(len(y_L)):
          L_extract_x = self.etai_M[y_i][:]
          if id == 1:
              L_extract_x = list(L_extract_x)
              L_extract_x.reverse()
          if max(L_extract_x)&gt;0.5 and min(L_extract_x)&lt;0.5:
              y_intersect = y_L[len(y_L)-1-y_i]
              for x_i in range(len(x_L)-1):
                  if (L_extract_x[x_i]-0.5)*(L_extract_x[x_i+1]-0.5)&lt;0:
                      x_intersect = (0.5-L_extract_x[x_i])/(L_extract_x[x_i+1]-L_extract_x[x_i])*\
                                  (x_L[x_i+1]-x_L[x_i]) + x_L[x_i]
                      L_border_old.append(np.array([x_intersect,y_intersect]))

      for x_i in range(len(x_L)):
          L_extract_y = []
          for y_i in range(len(y_L)):
              L_extract_y.append(self.etai_M[y_i][x_i])
          if max(L_extract_y)&gt;0.5 and min(L_extract_y)&lt;0.5:
              x_intersect = x_L[x_i]
              for y_i in range(len(y_L)-1):
                  if (L_extract_y[y_i]-0.5)*(L_extract_y[y_i+1]-0.5)&lt;0:
                      y_intersect = (0.5-L_extract_y[y_i])/(L_extract_y[y_i+1]-L_extract_y[y_i])*\
                                  (y_L[len(y_L)-1-y_i-1]-y_L[len(y_L)-1-y_i]) + y_L[len(y_L)-1-y_i]
                      L_border_old.append(np.array([x_intersect,y_intersect]))

      #Adaptating
      L_id_used = [0]
      L_border = [L_border_old[0]]
      HighValue = 100000000 #Large

      current_node = L_border_old[0]
      for j in range(1,len(L_border_old)):
          L_d = list(np.zeros(len(L_border_old)))
          for i in range(0,len(L_border_old)):
              node = L_border_old[i]
              if  i not in L_id_used:
                  d = np.linalg.norm(node - current_node)
                  L_d[i] = d
              else :
                  L_d[i] = HighValue #Value need to be larger than potential distance between node

          index_nearest_node = L_d.index(min(L_d))
          nearest_node = L_border_old[index_nearest_node]
          current_node = nearest_node
          L_border.append(nearest_node)
          L_id_used.append(index_nearest_node)

      #Correcting
      L_d_final = []
      for i in range(len(L_border)-1):
          L_d_final.append(np.linalg.norm(L_border[i+1] - L_border[i]))

      #look for really far points, we assume the first point is accurate
      d_final_mean = np.mean(L_d_final)
      while np.max(L_d_final) &gt; 5 * d_final_mean : #5 here is an user choixe value
          i_error = L_d_final.index(np.max(L_d_final))+1
          simulation_report.write(&#39;Point &#39;+str(L_border[i_error])+&#39; is deleted because it is detected as an error\n&#39;)
          L_border.pop(i_error)
          L_id_used.pop(i_error)
          L_d_final = []
          for i in range(len(L_border)-1):
              L_d_final.append(np.linalg.norm(L_border[i+1] - L_border[i]))

      #-------------------------------------------------------------------------------
      #Reduce the number of nodes for a grain
      #-------------------------------------------------------------------------------

      Perimeter = 0
      for i_p in range(len(L_border)-1):
          Perimeter = Perimeter + np.linalg.norm(L_border[i_p+1]-L_border[i_p])
      Perimeter = Perimeter + np.linalg.norm(L_border[-1]-L_border[0])
      distance_min = Perimeter/n
      L_border_adapted = [L_border[0]]
      for p in L_border[1:]:
          distance = np.linalg.norm(p-L_border_adapted[-1])
          if distance &gt;= distance_min:
              L_border_adapted.append(p)
      L_border = L_border_adapted
      L_border.append(L_border[0])
      self.l_border = L_border

      #-------------------------------------------------------------------------------
      #Monte carlo method
      #-------------------------------------------------------------------------------

      min_max_defined = False
      for p in L_border[:-1] :
          if not min_max_defined:
              box_min_x = p[0]
              box_max_x = p[0]
              box_min_y = p[1]
              box_max_y = p[1]
              min_max_defined = True
          else:
              if p[0] &lt; box_min_x:
                  box_min_x = p[0]
              elif p[0] &gt; box_max_x:
                  box_max_x = p[0]
              if p[1] &lt; box_min_y:
                  box_min_y = p[1]
              elif p[1] &gt; box_max_y:
                  box_max_y = p[1]

      N_MonteCarlo = 3000 #The larger it is, the more accurate it is
      sigma = self.rho_surf #kg/µm2
      M_Mass = 0
      M_Center_Mass = np.array([0,0])
      M_Inertia = 0

      for i in range(N_MonteCarlo):
          P = np.array([random.uniform(box_min_x,box_max_x),random.uniform(box_min_y,box_max_y)])
          if self.P_is_inside(P):
              M_Mass = M_Mass + sigma
              M_Center_Mass = M_Center_Mass + sigma*P
              M_Inertia = M_Inertia + sigma*np.dot(P,P)

      Mass = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Mass
      Center_Mass = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Center_Mass/Mass
      Inertia = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Inertia-Mass*np.dot(Center_Mass,Center_Mass)

      #-------------------------------------------------------------------------------
      #Updating the grain geometry and properties
      #-------------------------------------------------------------------------------

      L_R = []
      L_theta_R = []
      L_border_x = []
      L_border_y = []
      for p in L_border[:-1]:
          L_R.append(np.linalg.norm(p-Center_Mass))
          L_border_x.append(p[0])
          L_border_y.append(p[1])
          if (p-Center_Mass)[1] &gt; 0:
              theta = math.acos((p-Center_Mass)[0]/np.linalg.norm(p-Center_Mass))
          else :
              theta = 2*math.pi - math.acos((p-Center_Mass)[0]/np.linalg.norm(p-Center_Mass))
          L_theta_R.append(theta)
      L_border_x.append(L_border_x[0])
      L_border_y.append(L_border_y[0])
      #reorganize lists
      L_R.reverse()
      L_theta_R.reverse()
      i_min_theta = L_theta_R.index(min(L_theta_R))
      L_R = L_R[i_min_theta:]+L_R[:i_min_theta]
      L_theta_R = L_theta_R[i_min_theta:]+L_theta_R[:i_min_theta]

      self.r_min = np.min(L_R)
      self.r_max = np.max(L_R)
      self.r_mean = np.mean(L_R)
      self.l_r = L_R
      self.l_theta_r = L_theta_R
      self.surface = Mass/self.rho_surf
      self.m = Mass
      self.center = Center_Mass
      self.l_border_x = L_border_x
      self.l_border_y = L_border_y
      self.inertia = Inertia

#-------------------------------------------------------------------------------

  def P_is_inside(self,P):
      &#34;&#34;&#34;
      Determine if a point P is inside a grain.

      See Franklin 1994, see Alonso-Marroquin 2009

        Input :
            itself (a grain)
            a point (a 1 x 2 numpy array)
        Output :
            a Boolean, True if the point is inside the grain (a Boolean²)
      &#34;&#34;&#34;
      counter = 0
      for i_p_border in range(len(self.l_border)-1):
          #consider only points if the coordinates frame the y-coordinate of the point
          if (self.l_border[i_p_border][1]-P[1])*(self.l_border[i_p_border+1][1]-P[1]) &lt; 0 :
            x_border = self.l_border[i_p_border][0] + (self.l_border[i_p_border+1][0]-self.l_border[i_p_border][0])*(P[1]-self.l_border[i_p_border][1])/(self.l_border[i_p_border+1][1]-self.l_border[i_p_border][1])
            if x_border &gt; P[0] :
                counter = counter + 1
      if counter % 2 == 0:
        return False
      else :
        return True

#-------------------------------------------------------------------------------

  def Write_e_dissolution_local_txt(self,dict_algorithm,dict_sollicitations):
      &#34;&#34;&#34;
      Write an .txt file for MOOSE. This file described an homogenous dissolution field.

        Input :
            itself (a grain)
            an algorithm dictionnary (a dict)
            a sollicitations dictionnary (a dict)
        Output :
            Nothing, but a .txt file is generated (a file)
      &#34;&#34;&#34;
      file_to_write = open(f&#34;Data/e_diss_g{self.id}_ite{dict_algorithm[&#39;i_PF&#39;]}.txt&#34;,&#39;w&#39;)
      file_to_write.write(&#39;AXIS X\n&#39;)
      line = &#39;&#39;
      for x in self.x_L_local:
          line = line + str(x)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;AXIS Y\n&#39;)
      line = &#39;&#39;
      for y in self.y_L_local:
        line = line + str(y)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;DATA\n&#39;)
      for l in range(len(self.y_L_local)):
          for c in range(len(self.x_L_local)):
              file_to_write.write(str(dict_sollicitations[&#39;Dissolution_Energy&#39;])+&#39;\n&#39;)

      file_to_write.close()

#-------------------------------------------------------------------------------

  def Compute_etaiM_local(self,dict_algorithm,dict_material):
      &#34;&#34;&#34;
      From the grain geometry the phase variable is rebuilt.

      The distance between the point of the mesh and the particle center determines the value of the variable
      A cosine profile is applied inside the interface

        Input :
            itself (a grain)
            an algorithm dictionnary (a dict)
            a material dictionnary (a dict)
        Output :
            Nothing, but the grain gets an updated phase field (a nx x ny numpy array)
      &#34;&#34;&#34;
      x_min_local = min(self.l_border_x)-dict_material[&#39;w&#39;]
      x_max_local = max(self.l_border_x)+dict_material[&#39;w&#39;]
      y_min_local = min(self.l_border_y)-dict_material[&#39;w&#39;]
      y_max_local = max(self.l_border_y)+dict_material[&#39;w&#39;]
      x_L_local = np.arange(x_min_local,x_max_local+dict_algorithm[&#39;dx_local&#39;],dict_algorithm[&#39;dx_local&#39;])
      y_L_local = np.arange(y_min_local,y_max_local+dict_algorithm[&#39;dy_local&#39;],dict_algorithm[&#39;dy_local&#39;])

      self.x_L_local = x_L_local
      self.y_L_local = y_L_local

      # compute phase field
      etai_M = np.array(np.zeros((len(y_L_local),len(x_L_local))))
      for i_x in range(len(x_L_local)):
          for i_y in range(len(y_L_local)):
              p = np.array([x_L_local[i_x],y_L_local[len(y_L_local)-1-i_y]])
              r = np.linalg.norm(self.center - p)
              if p[1]&gt;self.center[1]:
                  theta = math.acos((p[0]-self.center[0])/np.linalg.norm(self.center-p))
              else :
                  theta= 2*math.pi - math.acos((p[0]-self.center[0])/np.linalg.norm(self.center-p))

              L_theta_R_i = list(abs(np.array(self.l_theta_r)-theta))
              R = self.l_r[L_theta_R_i.index(min(L_theta_R_i))]
              #Cosine_Profile
              if r&lt;R-dict_material[&#39;w&#39;]/2:
                  etai_M[i_y][i_x] = 1
              elif r&gt;R+dict_material[&#39;w&#39;]/2:
                  etai_M[i_y][i_x] = 0
              else :
                  etai_M[i_y][i_x] = 0.5*(1 + np.cos(math.pi*(r-R+dict_material[&#39;w&#39;]/2)/dict_material[&#39;w&#39;]))
      self.etai_M = etai_M.copy()

#-------------------------------------------------------------------------------

  def Write_txt_Decons_rebuild_local(self,dict_algorithm):
      &#34;&#34;&#34;
      Write a .txt file. This file is used to define initial condition of MOOSE simulation.

        Input :
            itself (a grain)
            an algorithm dictionnary (a dict)
        Output :
            Nothing, but a .txt file is generated (a file)
      &#34;&#34;&#34;
      file_to_write = open(&#39;Data/g&#39;+str(self.id)+&#39;_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;.txt&#39;,&#39;w&#39;)
      file_to_write.write(&#39;AXIS X\n&#39;)
      line = &#39;&#39;
      for x in self.x_L_local:
          line = line + str(x)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;AXIS Y\n&#39;)
      line = &#39;&#39;
      for y in self.y_L_local:
        line = line + str(y)+ &#39; &#39;
      line = line + &#39;\n&#39;
      file_to_write.write(line)

      file_to_write.write(&#39;DATA\n&#39;)
      for l in range(len(self.y_L_local)):
          for c in range(len(self.x_L_local)):
              file_to_write.write(str(self.etai_M[-l-1][c])+&#39;\n&#39;)

      file_to_write.close()

#-------------------------------------------------------------------------------

  def PFtoDEM_Multi_local(self,FileToRead,dict_algorithm):
    &#34;&#34;&#34;
    Read data from the moose simulation.

        Input :
            itself (a grain)
            the template of the name to read (a string)
            an algorithm dictionnary (a dict)
        Output :
            Nothing, but the phase field variable is updated (a nx x ny numpy array)
    &#34;&#34;&#34;
    #---------------------------------------------------------------------------
    #Global parameters
    #---------------------------------------------------------------------------

    etai_M = np.zeros((len(self.y_L_local),len(self.x_L_local))) #etai

    id_L = None
    eta_selector_len = len(&#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;etai&#39;)
    end_len = len(&#39;        &lt;/DataArray&gt;&#39;)
    XYZ_selector_len = len(&#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;Points&#34;&#39;)
    data_jump_len = len(&#39;          &#39;)

    for i_proc in range(dict_algorithm[&#39;np_proc&#39;]):

        L_Work = [[], #X
                  [], #Y
                  []] #etai

    #---------------------------------------------------------------------------
    #Reading file
    #---------------------------------------------------------------------------

        f = open(f&#39;{FileToRead}_{i_proc}.vtu&#39;,&#39;r&#39;)
        data = f.read()
        f.close
        lines = data.splitlines()

        #iterations on line
        for line in lines:

            if line[0:eta_selector_len] == &#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;etai&#39;:
                id_L = 2

            elif line[0:XYZ_selector_len] == &#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;Points&#34;&#39;:
                id_L = 0

            elif (line[0:end_len] == &#39;        &lt;/DataArray&gt;&#39; or  line[0:len(&#39;          &lt;InformationKey&#39;)] == &#39;          &lt;InformationKey&#39;) and id_L != None:
                id_L = None

            elif line[0:data_jump_len] == &#39;          &#39; and id_L == 2: #Read etai
                line = line[data_jump_len:]
                c_start = 0
                for c_i in range(0,len(line)):
                    if line[c_i]==&#39; &#39;:
                        c_end = c_i
                        L_Work[id_L].append(float(line[c_start:c_end]))
                        c_start = c_i+1
                L_Work[id_L].append(float(line[c_start:]))

            elif line[0:data_jump_len] == &#39;          &#39; and id_L == 0: #Read [X, Y, Z]
                line = line[data_jump_len:]
                XYZ_temp = []
                c_start = 0
                for c_i in range(0,len(line)):
                    if line[c_i]==&#39; &#39;:
                        c_end = c_i
                        XYZ_temp.append(float(line[c_start:c_end]))
                        if len(XYZ_temp)==3:
                            L_Work[0].append(XYZ_temp[0])
                            L_Work[1].append(XYZ_temp[1])
                            XYZ_temp = []
                        c_start = c_i+1
                XYZ_temp.append(float(line[c_start:]))
                L_Work[0].append(XYZ_temp[0])
                L_Work[1].append(XYZ_temp[1])

        #Adaptating data
        for i in range(len(L_Work[0])):
            #Interpolation method
            L_dy = []
            for y_i in self.y_L_local :
                L_dy.append(abs(y_i - L_Work[1][i]))
            L_dx = []
            for x_i in self.x_L_local :
                L_dx.append(abs(x_i - L_Work[0][i]))
            etai_M[-1-list(L_dy).index(min(L_dy))][list(L_dx).index(min(L_dx))] = L_Work[2][i]

    # Update
    self.etai_M = etai_M.copy()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Grain.Grain.Compute_etaiM_local"><code class="name flex">
<span>def <span class="ident">Compute_etaiM_local</span></span>(<span>self, dict_algorithm, dict_material)</span>
</code></dt>
<dd>
<div class="desc"><p>From the grain geometry the phase variable is rebuilt.</p>
<p>The distance between the point of the mesh and the particle center determines the value of the variable
A cosine profile is applied inside the interface</p>
<p>Input :
itself (a grain)
an algorithm dictionnary (a dict)
a material dictionnary (a dict)
Output :
Nothing, but the grain gets an updated phase field (a nx x ny numpy array)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Compute_etaiM_local(self,dict_algorithm,dict_material):
    &#34;&#34;&#34;
    From the grain geometry the phase variable is rebuilt.

    The distance between the point of the mesh and the particle center determines the value of the variable
    A cosine profile is applied inside the interface

      Input :
          itself (a grain)
          an algorithm dictionnary (a dict)
          a material dictionnary (a dict)
      Output :
          Nothing, but the grain gets an updated phase field (a nx x ny numpy array)
    &#34;&#34;&#34;
    x_min_local = min(self.l_border_x)-dict_material[&#39;w&#39;]
    x_max_local = max(self.l_border_x)+dict_material[&#39;w&#39;]
    y_min_local = min(self.l_border_y)-dict_material[&#39;w&#39;]
    y_max_local = max(self.l_border_y)+dict_material[&#39;w&#39;]
    x_L_local = np.arange(x_min_local,x_max_local+dict_algorithm[&#39;dx_local&#39;],dict_algorithm[&#39;dx_local&#39;])
    y_L_local = np.arange(y_min_local,y_max_local+dict_algorithm[&#39;dy_local&#39;],dict_algorithm[&#39;dy_local&#39;])

    self.x_L_local = x_L_local
    self.y_L_local = y_L_local

    # compute phase field
    etai_M = np.array(np.zeros((len(y_L_local),len(x_L_local))))
    for i_x in range(len(x_L_local)):
        for i_y in range(len(y_L_local)):
            p = np.array([x_L_local[i_x],y_L_local[len(y_L_local)-1-i_y]])
            r = np.linalg.norm(self.center - p)
            if p[1]&gt;self.center[1]:
                theta = math.acos((p[0]-self.center[0])/np.linalg.norm(self.center-p))
            else :
                theta= 2*math.pi - math.acos((p[0]-self.center[0])/np.linalg.norm(self.center-p))

            L_theta_R_i = list(abs(np.array(self.l_theta_r)-theta))
            R = self.l_r[L_theta_R_i.index(min(L_theta_R_i))]
            #Cosine_Profile
            if r&lt;R-dict_material[&#39;w&#39;]/2:
                etai_M[i_y][i_x] = 1
            elif r&gt;R+dict_material[&#39;w&#39;]/2:
                etai_M[i_y][i_x] = 0
            else :
                etai_M[i_y][i_x] = 0.5*(1 + np.cos(math.pi*(r-R+dict_material[&#39;w&#39;]/2)/dict_material[&#39;w&#39;]))
    self.etai_M = etai_M.copy()</code></pre>
</details>
</dd>
<dt id="Grain.Grain.Geometricstudy_local"><code class="name flex">
<span>def <span class="ident">Geometricstudy_local</span></span>(<span>self, dict_geometry, dict_sample, simulation_report)</span>
</code></dt>
<dd>
<div class="desc"><p>Searching border of the grain.</p>
<p>We iterate on y constant, we look for a value under and over 0.5.
If both conditions are verified, there is a limit at this y
Same with iteration on x constant.</p>
<p>Then, searching Surface, Center of mass and Inertia.
A Monte Carlo Method is applied.
A box is defined, we take a random point and we look if it is inside or outside the grain.
Properties are the statistic times the box properties.</p>
<p>Input :
itself (a grain)
a geometry dictionnary (a dict)
a sample dictionnary (a dict)
a simulation report (a report)
Output :
Nothing, but geometric parameters are updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Geometricstudy_local(self,dict_geometry,dict_sample,simulation_report):
    &#34;&#34;&#34;
    Searching border of the grain.

    We iterate on y constant, we look for a value under and over 0.5.
    If both conditions are verified, there is a limit at this y
    Same with iteration on x constant.

    Then, searching Surface, Center of mass and Inertia.
    A Monte Carlo Method is applied.
    A box is defined, we take a random point and we look if it is inside or outside the grain.
    Properties are the statistic times the box properties.

      Input :
          itself (a grain)
          a geometry dictionnary (a dict)
          a sample dictionnary (a dict)
          a simulation report (a report)
      Output :
          Nothing, but geometric parameters are updated
    &#34;&#34;&#34;
    #-------------------------------------------------------------------------
    #load data needed
    n = dict_geometry[&#39;grain_discretisation&#39;]
    x_L = self.x_L_local
    y_L = self.y_L_local
    #-------------------------------------------------------------------------

    L_border_old = []
    for y_i in range(len(y_L)):
        L_extract_x = self.etai_M[y_i][:]
        if id == 1:
            L_extract_x = list(L_extract_x)
            L_extract_x.reverse()
        if max(L_extract_x)&gt;0.5 and min(L_extract_x)&lt;0.5:
            y_intersect = y_L[len(y_L)-1-y_i]
            for x_i in range(len(x_L)-1):
                if (L_extract_x[x_i]-0.5)*(L_extract_x[x_i+1]-0.5)&lt;0:
                    x_intersect = (0.5-L_extract_x[x_i])/(L_extract_x[x_i+1]-L_extract_x[x_i])*\
                                (x_L[x_i+1]-x_L[x_i]) + x_L[x_i]
                    L_border_old.append(np.array([x_intersect,y_intersect]))

    for x_i in range(len(x_L)):
        L_extract_y = []
        for y_i in range(len(y_L)):
            L_extract_y.append(self.etai_M[y_i][x_i])
        if max(L_extract_y)&gt;0.5 and min(L_extract_y)&lt;0.5:
            x_intersect = x_L[x_i]
            for y_i in range(len(y_L)-1):
                if (L_extract_y[y_i]-0.5)*(L_extract_y[y_i+1]-0.5)&lt;0:
                    y_intersect = (0.5-L_extract_y[y_i])/(L_extract_y[y_i+1]-L_extract_y[y_i])*\
                                (y_L[len(y_L)-1-y_i-1]-y_L[len(y_L)-1-y_i]) + y_L[len(y_L)-1-y_i]
                    L_border_old.append(np.array([x_intersect,y_intersect]))

    #Adaptating
    L_id_used = [0]
    L_border = [L_border_old[0]]
    HighValue = 100000000 #Large

    current_node = L_border_old[0]
    for j in range(1,len(L_border_old)):
        L_d = list(np.zeros(len(L_border_old)))
        for i in range(0,len(L_border_old)):
            node = L_border_old[i]
            if  i not in L_id_used:
                d = np.linalg.norm(node - current_node)
                L_d[i] = d
            else :
                L_d[i] = HighValue #Value need to be larger than potential distance between node

        index_nearest_node = L_d.index(min(L_d))
        nearest_node = L_border_old[index_nearest_node]
        current_node = nearest_node
        L_border.append(nearest_node)
        L_id_used.append(index_nearest_node)

    #Correcting
    L_d_final = []
    for i in range(len(L_border)-1):
        L_d_final.append(np.linalg.norm(L_border[i+1] - L_border[i]))

    #look for really far points, we assume the first point is accurate
    d_final_mean = np.mean(L_d_final)
    while np.max(L_d_final) &gt; 5 * d_final_mean : #5 here is an user choixe value
        i_error = L_d_final.index(np.max(L_d_final))+1
        simulation_report.write(&#39;Point &#39;+str(L_border[i_error])+&#39; is deleted because it is detected as an error\n&#39;)
        L_border.pop(i_error)
        L_id_used.pop(i_error)
        L_d_final = []
        for i in range(len(L_border)-1):
            L_d_final.append(np.linalg.norm(L_border[i+1] - L_border[i]))

    #-------------------------------------------------------------------------------
    #Reduce the number of nodes for a grain
    #-------------------------------------------------------------------------------

    Perimeter = 0
    for i_p in range(len(L_border)-1):
        Perimeter = Perimeter + np.linalg.norm(L_border[i_p+1]-L_border[i_p])
    Perimeter = Perimeter + np.linalg.norm(L_border[-1]-L_border[0])
    distance_min = Perimeter/n
    L_border_adapted = [L_border[0]]
    for p in L_border[1:]:
        distance = np.linalg.norm(p-L_border_adapted[-1])
        if distance &gt;= distance_min:
            L_border_adapted.append(p)
    L_border = L_border_adapted
    L_border.append(L_border[0])
    self.l_border = L_border

    #-------------------------------------------------------------------------------
    #Monte carlo method
    #-------------------------------------------------------------------------------

    min_max_defined = False
    for p in L_border[:-1] :
        if not min_max_defined:
            box_min_x = p[0]
            box_max_x = p[0]
            box_min_y = p[1]
            box_max_y = p[1]
            min_max_defined = True
        else:
            if p[0] &lt; box_min_x:
                box_min_x = p[0]
            elif p[0] &gt; box_max_x:
                box_max_x = p[0]
            if p[1] &lt; box_min_y:
                box_min_y = p[1]
            elif p[1] &gt; box_max_y:
                box_max_y = p[1]

    N_MonteCarlo = 3000 #The larger it is, the more accurate it is
    sigma = self.rho_surf #kg/µm2
    M_Mass = 0
    M_Center_Mass = np.array([0,0])
    M_Inertia = 0

    for i in range(N_MonteCarlo):
        P = np.array([random.uniform(box_min_x,box_max_x),random.uniform(box_min_y,box_max_y)])
        if self.P_is_inside(P):
            M_Mass = M_Mass + sigma
            M_Center_Mass = M_Center_Mass + sigma*P
            M_Inertia = M_Inertia + sigma*np.dot(P,P)

    Mass = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Mass
    Center_Mass = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Center_Mass/Mass
    Inertia = (box_max_x-box_min_x)*(box_max_y-box_min_y)/N_MonteCarlo*M_Inertia-Mass*np.dot(Center_Mass,Center_Mass)

    #-------------------------------------------------------------------------------
    #Updating the grain geometry and properties
    #-------------------------------------------------------------------------------

    L_R = []
    L_theta_R = []
    L_border_x = []
    L_border_y = []
    for p in L_border[:-1]:
        L_R.append(np.linalg.norm(p-Center_Mass))
        L_border_x.append(p[0])
        L_border_y.append(p[1])
        if (p-Center_Mass)[1] &gt; 0:
            theta = math.acos((p-Center_Mass)[0]/np.linalg.norm(p-Center_Mass))
        else :
            theta = 2*math.pi - math.acos((p-Center_Mass)[0]/np.linalg.norm(p-Center_Mass))
        L_theta_R.append(theta)
    L_border_x.append(L_border_x[0])
    L_border_y.append(L_border_y[0])
    #reorganize lists
    L_R.reverse()
    L_theta_R.reverse()
    i_min_theta = L_theta_R.index(min(L_theta_R))
    L_R = L_R[i_min_theta:]+L_R[:i_min_theta]
    L_theta_R = L_theta_R[i_min_theta:]+L_theta_R[:i_min_theta]

    self.r_min = np.min(L_R)
    self.r_max = np.max(L_R)
    self.r_mean = np.mean(L_R)
    self.l_r = L_R
    self.l_theta_r = L_theta_R
    self.surface = Mass/self.rho_surf
    self.m = Mass
    self.center = Center_Mass
    self.l_border_x = L_border_x
    self.l_border_y = L_border_y
    self.inertia = Inertia</code></pre>
</details>
</dd>
<dt id="Grain.Grain.PFtoDEM_Multi_local"><code class="name flex">
<span>def <span class="ident">PFtoDEM_Multi_local</span></span>(<span>self, FileToRead, dict_algorithm)</span>
</code></dt>
<dd>
<div class="desc"><p>Read data from the moose simulation.</p>
<pre><code>Input :
    itself (a grain)
    the template of the name to read (a string)
    an algorithm dictionnary (a dict)
Output :
    Nothing, but the phase field variable is updated (a nx x ny numpy array)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PFtoDEM_Multi_local(self,FileToRead,dict_algorithm):
  &#34;&#34;&#34;
  Read data from the moose simulation.

      Input :
          itself (a grain)
          the template of the name to read (a string)
          an algorithm dictionnary (a dict)
      Output :
          Nothing, but the phase field variable is updated (a nx x ny numpy array)
  &#34;&#34;&#34;
  #---------------------------------------------------------------------------
  #Global parameters
  #---------------------------------------------------------------------------

  etai_M = np.zeros((len(self.y_L_local),len(self.x_L_local))) #etai

  id_L = None
  eta_selector_len = len(&#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;etai&#39;)
  end_len = len(&#39;        &lt;/DataArray&gt;&#39;)
  XYZ_selector_len = len(&#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;Points&#34;&#39;)
  data_jump_len = len(&#39;          &#39;)

  for i_proc in range(dict_algorithm[&#39;np_proc&#39;]):

      L_Work = [[], #X
                [], #Y
                []] #etai

  #---------------------------------------------------------------------------
  #Reading file
  #---------------------------------------------------------------------------

      f = open(f&#39;{FileToRead}_{i_proc}.vtu&#39;,&#39;r&#39;)
      data = f.read()
      f.close
      lines = data.splitlines()

      #iterations on line
      for line in lines:

          if line[0:eta_selector_len] == &#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;etai&#39;:
              id_L = 2

          elif line[0:XYZ_selector_len] == &#39;        &lt;DataArray type=&#34;Float64&#34; Name=&#34;Points&#34;&#39;:
              id_L = 0

          elif (line[0:end_len] == &#39;        &lt;/DataArray&gt;&#39; or  line[0:len(&#39;          &lt;InformationKey&#39;)] == &#39;          &lt;InformationKey&#39;) and id_L != None:
              id_L = None

          elif line[0:data_jump_len] == &#39;          &#39; and id_L == 2: #Read etai
              line = line[data_jump_len:]
              c_start = 0
              for c_i in range(0,len(line)):
                  if line[c_i]==&#39; &#39;:
                      c_end = c_i
                      L_Work[id_L].append(float(line[c_start:c_end]))
                      c_start = c_i+1
              L_Work[id_L].append(float(line[c_start:]))

          elif line[0:data_jump_len] == &#39;          &#39; and id_L == 0: #Read [X, Y, Z]
              line = line[data_jump_len:]
              XYZ_temp = []
              c_start = 0
              for c_i in range(0,len(line)):
                  if line[c_i]==&#39; &#39;:
                      c_end = c_i
                      XYZ_temp.append(float(line[c_start:c_end]))
                      if len(XYZ_temp)==3:
                          L_Work[0].append(XYZ_temp[0])
                          L_Work[1].append(XYZ_temp[1])
                          XYZ_temp = []
                      c_start = c_i+1
              XYZ_temp.append(float(line[c_start:]))
              L_Work[0].append(XYZ_temp[0])
              L_Work[1].append(XYZ_temp[1])

      #Adaptating data
      for i in range(len(L_Work[0])):
          #Interpolation method
          L_dy = []
          for y_i in self.y_L_local :
              L_dy.append(abs(y_i - L_Work[1][i]))
          L_dx = []
          for x_i in self.x_L_local :
              L_dx.append(abs(x_i - L_Work[0][i]))
          etai_M[-1-list(L_dy).index(min(L_dy))][list(L_dx).index(min(L_dx))] = L_Work[2][i]

  # Update
  self.etai_M = etai_M.copy()</code></pre>
</details>
</dd>
<dt id="Grain.Grain.P_is_inside"><code class="name flex">
<span>def <span class="ident">P_is_inside</span></span>(<span>self, P)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if a point P is inside a grain.</p>
<p>See Franklin 1994, see Alonso-Marroquin 2009</p>
<p>Input :
itself (a grain)
a point (a 1 x 2 numpy array)
Output :
a Boolean, True if the point is inside the grain (a Boolean²)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def P_is_inside(self,P):
    &#34;&#34;&#34;
    Determine if a point P is inside a grain.

    See Franklin 1994, see Alonso-Marroquin 2009

      Input :
          itself (a grain)
          a point (a 1 x 2 numpy array)
      Output :
          a Boolean, True if the point is inside the grain (a Boolean²)
    &#34;&#34;&#34;
    counter = 0
    for i_p_border in range(len(self.l_border)-1):
        #consider only points if the coordinates frame the y-coordinate of the point
        if (self.l_border[i_p_border][1]-P[1])*(self.l_border[i_p_border+1][1]-P[1]) &lt; 0 :
          x_border = self.l_border[i_p_border][0] + (self.l_border[i_p_border+1][0]-self.l_border[i_p_border][0])*(P[1]-self.l_border[i_p_border][1])/(self.l_border[i_p_border+1][1]-self.l_border[i_p_border][1])
          if x_border &gt; P[0] :
              counter = counter + 1
    if counter % 2 == 0:
      return False
    else :
      return True</code></pre>
</details>
</dd>
<dt id="Grain.Grain.Write_e_dissolution_local_txt"><code class="name flex">
<span>def <span class="ident">Write_e_dissolution_local_txt</span></span>(<span>self, dict_algorithm, dict_sollicitations)</span>
</code></dt>
<dd>
<div class="desc"><p>Write an .txt file for MOOSE. This file described an homogenous dissolution field.</p>
<p>Input :
itself (a grain)
an algorithm dictionnary (a dict)
a sollicitations dictionnary (a dict)
Output :
Nothing, but a .txt file is generated (a file)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Write_e_dissolution_local_txt(self,dict_algorithm,dict_sollicitations):
    &#34;&#34;&#34;
    Write an .txt file for MOOSE. This file described an homogenous dissolution field.

      Input :
          itself (a grain)
          an algorithm dictionnary (a dict)
          a sollicitations dictionnary (a dict)
      Output :
          Nothing, but a .txt file is generated (a file)
    &#34;&#34;&#34;
    file_to_write = open(f&#34;Data/e_diss_g{self.id}_ite{dict_algorithm[&#39;i_PF&#39;]}.txt&#34;,&#39;w&#39;)
    file_to_write.write(&#39;AXIS X\n&#39;)
    line = &#39;&#39;
    for x in self.x_L_local:
        line = line + str(x)+ &#39; &#39;
    line = line + &#39;\n&#39;
    file_to_write.write(line)

    file_to_write.write(&#39;AXIS Y\n&#39;)
    line = &#39;&#39;
    for y in self.y_L_local:
      line = line + str(y)+ &#39; &#39;
    line = line + &#39;\n&#39;
    file_to_write.write(line)

    file_to_write.write(&#39;DATA\n&#39;)
    for l in range(len(self.y_L_local)):
        for c in range(len(self.x_L_local)):
            file_to_write.write(str(dict_sollicitations[&#39;Dissolution_Energy&#39;])+&#39;\n&#39;)

    file_to_write.close()</code></pre>
</details>
</dd>
<dt id="Grain.Grain.Write_txt_Decons_rebuild_local"><code class="name flex">
<span>def <span class="ident">Write_txt_Decons_rebuild_local</span></span>(<span>self, dict_algorithm)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a .txt file. This file is used to define initial condition of MOOSE simulation.</p>
<p>Input :
itself (a grain)
an algorithm dictionnary (a dict)
Output :
Nothing, but a .txt file is generated (a file)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Write_txt_Decons_rebuild_local(self,dict_algorithm):
    &#34;&#34;&#34;
    Write a .txt file. This file is used to define initial condition of MOOSE simulation.

      Input :
          itself (a grain)
          an algorithm dictionnary (a dict)
      Output :
          Nothing, but a .txt file is generated (a file)
    &#34;&#34;&#34;
    file_to_write = open(&#39;Data/g&#39;+str(self.id)+&#39;_&#39;+str(dict_algorithm[&#39;i_PF&#39;])+&#39;.txt&#39;,&#39;w&#39;)
    file_to_write.write(&#39;AXIS X\n&#39;)
    line = &#39;&#39;
    for x in self.x_L_local:
        line = line + str(x)+ &#39; &#39;
    line = line + &#39;\n&#39;
    file_to_write.write(line)

    file_to_write.write(&#39;AXIS Y\n&#39;)
    line = &#39;&#39;
    for y in self.y_L_local:
      line = line + str(y)+ &#39; &#39;
    line = line + &#39;\n&#39;
    file_to_write.write(line)

    file_to_write.write(&#39;DATA\n&#39;)
    for l in range(len(self.y_L_local)):
        for c in range(len(self.x_L_local)):
            file_to_write.write(str(self.etai_M[-l-1][c])+&#39;\n&#39;)

    file_to_write.close()</code></pre>
</details>
</dd>
<dt id="Grain.Grain.init_f_control"><code class="name flex">
<span>def <span class="ident">init_f_control</span></span>(<span>self, dict_sollicitations)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the force applied to the grain.</p>
<p>A gravity of g is applied.</p>
<p>Input :
itself (a grain)
a sollicitations dictionnary (a dict)
Ouput :
Nothing, but the force applied on the grain is initialized</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_f_control(self,dict_sollicitations):
    &#34;&#34;&#34;
    Initialize the force applied to the grain.

    A gravity of g is applied.

      Input :
          itself (a grain)
          a sollicitations dictionnary (a dict)
      Ouput :
          Nothing, but the force applied on the grain is initialized
    &#34;&#34;&#34;
    self.fx = 0
    self.fy = -dict_sollicitations[&#39;gravity&#39;]*self.m
    self.f = np.array([self.fx,self.fy])
    self.mz = 0</code></pre>
</details>
</dd>
<dt id="Grain.Grain.update_f"><code class="name flex">
<span>def <span class="ident">update_f</span></span>(<span>self, Fx, Fy, p_application)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a force to the grain.</p>
<pre><code>Input :
    itself (a grain)
    the value x and y of the force (two float)
    an applicaiton point (a 1 x 2 numpy array)
Output :
    Nothing, but a force is applied to the grain
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_f(self, Fx, Fy, p_application):
  &#34;&#34;&#34;
  Add a force to the grain.

      Input :
          itself (a grain)
          the value x and y of the force (two float)
          an applicaiton point (a 1 x 2 numpy array)
      Output :
          Nothing, but a force is applied to the grain
  &#34;&#34;&#34;
  self.fx = self.fx + Fx
  self.fy = self.fy + Fy
  self.f = np.array([self.fx,self.fy])

  v1 = np.array([p_application[0]-self.center[0], p_application[1]-self.center[1], 0])
  v2 = np.array([Fx, Fy, 0])
  self.mz = self.mz + np.cross(v1,v2)[2]</code></pre>
</details>
</dd>
<dt id="Grain.Grain.update_geometry_kinetic"><code class="name flex">
<span>def <span class="ident">update_geometry_kinetic</span></span>(<span>self, V, A, W, DT)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the acceleration and the velocity of a grain. Update geometrical parameters as border and center nodes.</p>
<pre><code>Input :
    itself (a grain)
    a speed (a 1 x 2 numpy array)
    an acceleration (a 1 x 2 numpy array)
    an angular speed (a float)
    a time step (a float)
Ouput :
    Nothing, but the position of the grain is updated
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_geometry_kinetic(self, V, A, W, DT):
  &#34;&#34;&#34;
  Update the acceleration and the velocity of a grain. Update geometrical parameters as border and center nodes.

      Input :
          itself (a grain)
          a speed (a 1 x 2 numpy array)
          an acceleration (a 1 x 2 numpy array)
          an angular speed (a float)
          a time step (a float)
      Ouput :
          Nothing, but the position of the grain is updated
  &#34;&#34;&#34;
  #translation
  self.v = V
  self.a = A
  for i in range(len(self.l_border)):
      self.l_border[i] = self.l_border[i] + self.v*DT
      self.l_border_x[i] = self.l_border_x[i] + self.v[0]*DT
      self.l_border_y[i] = self.l_border_y[i] + self.v[1]*DT
  self.center = self.center + self.v*DT

  #rotation
  self.w = W
  self.theta = self.theta + self.w*DT

  for i_theta_r in range(len(self.l_theta_r)) :
      theta_r = self.l_theta_r[i_theta_r]
      theta_r = theta_r + self.w*DT
      while theta_r &gt;= 2*math.pi:
          theta_r = theta_r - 2*math.pi
      while theta_r &lt; 0 :
          theta_r = theta_r + 2*math.pi
      self.l_theta_r[i_theta_r] = theta_r

  for i in range(len(self.l_border)):
      p = self.l_border[i] - self.center
      Rot_Matrix = np.array([[math.cos(self.w*DT), -math.sin(self.w*DT)],
                             [math.sin(self.w*DT),  math.cos(self.w*DT)]])
      p = np.dot(Rot_Matrix,p)
      self.l_border[i] = p + self.center
      self.l_border_x[i] = p[0] + self.center[0]
      self.l_border_y[i] = p[1] + self.center[1]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Grain.Grain" href="#Grain.Grain">Grain</a></code></h4>
<ul class="">
<li><code><a title="Grain.Grain.Compute_etaiM_local" href="#Grain.Grain.Compute_etaiM_local">Compute_etaiM_local</a></code></li>
<li><code><a title="Grain.Grain.Geometricstudy_local" href="#Grain.Grain.Geometricstudy_local">Geometricstudy_local</a></code></li>
<li><code><a title="Grain.Grain.PFtoDEM_Multi_local" href="#Grain.Grain.PFtoDEM_Multi_local">PFtoDEM_Multi_local</a></code></li>
<li><code><a title="Grain.Grain.P_is_inside" href="#Grain.Grain.P_is_inside">P_is_inside</a></code></li>
<li><code><a title="Grain.Grain.Write_e_dissolution_local_txt" href="#Grain.Grain.Write_e_dissolution_local_txt">Write_e_dissolution_local_txt</a></code></li>
<li><code><a title="Grain.Grain.Write_txt_Decons_rebuild_local" href="#Grain.Grain.Write_txt_Decons_rebuild_local">Write_txt_Decons_rebuild_local</a></code></li>
<li><code><a title="Grain.Grain.init_f_control" href="#Grain.Grain.init_f_control">init_f_control</a></code></li>
<li><code><a title="Grain.Grain.update_f" href="#Grain.Grain.update_f">update_f</a></code></li>
<li><code><a title="Grain.Grain.update_geometry_kinetic" href="#Grain.Grain.update_geometry_kinetic">update_geometry_kinetic</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>